# Python

## Типы данных
| Сокр |Тип рус | Характеристика | Упорядоченность | 
|  -----------  | ----------- | ----------- | ----------- | 
Int | Целое | Неизменяемые |  | 
|  | Комплексное | Неизменяемые |  | 
|  | Вещественное | Неизменяемые |  | 
| Str | Строки | Неизменяемые | Упорядоченные | 
| list | Списки | Изменяемые | Упорядоченные | 
| tuple | кортеж | Неизменяемые | Упорядоченные | 
| dict| словарь | Изменяемые | Упорядоченные | 
| set | Множество | Изменяемые | Упорядоченные | 
| bool | Булевое значение | Незменяемые | Упорядоченные | 


## Строки
### Методы строк
Метод — функция, применяемая к объекту. Метод вызывается в виде: 
`имя_объекта.имя_метода(параметры)`
- `x.capitalize()` – возвращает копию строки, в которой первый символ имеет верхний регистр, а остальные нижний
- `x.swapcase()` – возвращает копию строки, в которой все символы меняют регистр на противоположный
- `x.title()` – возвращает копию строки, в которой первый символ каждого слова переводится в  верхний регистр
- `x.lower()` – возвращает копию строки, в которой все символы имеют нижний регистр 
- `x.upper()` – возвращает копию строки, в которой все символы имеют верхний регистр 
- `x.count(<sub>,<start>,<end>)` – считает количество непересекающихся вхождений подстроки `<sub>` в строку
- `x.startswith(\<suffix>,\<start>,\<end>)` – определяет, начинается ли строка подстрокой `<suffix>`. Если начинается, возвращает значение  True, если нет – False
- `x.endswith(<suffix>,<start>,<end>)` – определяет, оканчивается ли строка подстрокой `<suffix>`. Если оканчивается, возвращает значение  True, если нет – False
- `x.find(<sub>,<start>,<end>)` – находит индекс первого вхождения подстроки `<sub>`. Если `<sub>` не встречается, выдает значение -1 
- `x.rfind(\<sub>,\<start>,\<end>)` – находит индекс первого вхождения подстроки <sub> с конца строки. Если <sub> не встречается, выдает значение -1 
- `x.index(\<sub>,\<start>,\<end>)` – идентичен x.find, за исключением если строка <sub> не найдена, выдает ошибку.
- `x.rindex(\<sub>,\<start>,\<end>)` – идентичен x.rfind, за исключением если строка <sub> не найдена, выдает ошибку.
- `x.strip()` – возвращает копию строки, в которой удалены все пробелы в начале и в конце строки.
- `x.lstrip()` – возвращает копию строки, в которой удалены все пробелы в начале строки.
- `x.rstrip()` – возвращает копию строки, в которой удалены все пробелы в конце строки.
- `x.strip(),x.lstrip()x.rstrip()` – могут принимать аргумент <chars>, определяющей набор символов для удаления.
- `x.replace(\<old>,\<new>,\<count>)` – возвращает копию строки, со всеми значениями \<old> замененными на <new>, \<count> определяет количество замен.
- `x.isalnum()` – определяет, состоит ли строка из букв или цифр. Возвращает True если строка является не пустой и состоит из букв и цифр, False в противном случае.
- `x.isalpha()` – определяет, состоит ли строка из букв. Возвращает True если строка является не пустой и состоит из букв, False в противном случае.
- `x.isdigit()` – определяет, состоит ли строка из цифр. Возвращает True если строка является не пустой и состоит из цифр, False в противном случае.
- `x.islower()` – определяет, являются ли все буквы строчными (нижний регистр), если все буквы имеют нижний регистр, выдает True, в противном случае выдает False. Все не алфавитные символы игнорируются.
- `x.isupper()` – определяет, являются ли все буквы заглавными (верхний регистр), если все буквы имеют верхний регистр, выдает True, в противном случае выдает False. Все не алфавитные символы игнорируются.
- `x.isspase()` – определяет состоит ли строка только из пробелов. Если строка только из пробелов, выдает True, в противном случае выдает False
- `num = ord()` – определяет код одного символа в таблице символов Unicode.
- `num = crh()` – определяет по числу  сам символ.

## Списки
Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.
### Методы списков
- `List()` – помимо создания пустого списка может преобразовывать некоторые типы объектов в списки
- `x.append()` – добавляет элемент в конец списка
- `x.extend()` – расширяет список другим списком
- `del x[]` – удаляет элемент списка по индексу
- `x.split(“ “)` – разбивает строку на слова, используя пробел в качестве разделителя (можно менять)
- `‘*‘.join.(x)` – собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод
- `x.insert(<index>,<value>)` – вставляет на  <index> значение <value>
- `x.index(<value>, <start>,<end>)` – возвращает индекс первого элемента, указанного значения
- `x.remove(<value>)` – удаляет первый элемент в списке, имеющий значение <value>. Если значения нет, выдает ошибку
- `x.pop(<index>)` – удаляет <index>, и возвращает его. Если <index> не указан, удаляет последний элемент
- `x.count(<value>)` – возвращает количество элементов со значением  <value>
- `x.reverse()` – разворачивает список
- `x.copy()` – копия списка
- `x.clear()` – очищает список
- `x.sort()` – сортирует исходный список по возрастанию, изменяет индексы, возвращает None
- `sorted(x)` – возвращает новый отсортированный список, исходный без изменений
- `x.sort(reverse=True)` – сортирует по убыванию


## Кортежы
Кортеж – неизменяемый последовательность символов (Неизменяемые аналоги списков)
`My_tuple = (1,)` – кортеж с одним элементом
Преимущества кортежей:
- скорость (работают быстрее, т.к. из-за неизменяемости хранятся в памяти иначе. Одна из причин сущствования кортежей – производительность. Обработка происходит быстрее, поэтому удобны для большого объема неизменяемых данных.
- безопасность (можно безопвсно хранить данные, не опасаясь что они будут случайно или преднамеренно изменены в программе)
Поддерживают:
-доступ к элементу по индексу (только для получения значений элементов);
-методы, в частности index(), count();
-встроенные функции, в частности len(), sum(), min() и max();
-срезы;
-оператор принадлежности in;
-операторы конкатенации (+) и повторения (*)
-а т.к. не изменяемые, не поддерживают sort(), которые меняют порядок, но поддерживают sorted()
преобразуются в строку с помощью “”.join()

Распаковка:
```
colors = ('red', 'green', 'blue', 'cyan')
 a, b, c, d = colors
```

Распаковка со звездочкой посередине

```
singer = ('one', 'two', 'three', 'four', 'five')
 name, *songs, surname = singer print(name) print(songs) print(surname)
```

Выводит:
one ['two', 'three', 'four'] five


## Булевые значения
True == 1
False == 0
None 

Для сравнения с None нужно использовать оператор не ==, а is, чтобы небыло проблем с типами

## Множества
Set() – пустое множество

Совокупность объектов, понимаемых как единое целое (множество студентов, множество натуральных чисел)  

### Важно знать:
•	Элементы множества – любые неизменяемые 
•	все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
•	множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
•	элементы множества должны относиться к неизменяемым типам данных;
•	хранящиеся в множестве элементы могут иметь разные типы данных
•	Индексация и срезы недоступны для множеств.
•	Операция конкатенации + и умножения на число * недоступны для множеств
•	При выводе порядок множества порядок меняется произвольным способом
 
### Методы множеств:
Встроенные функции len(), sum(), min(), max()
- `myset.add()` - добавляет новый элемент в множество.
- `issubset()` - Для определения, является ли одно из множеств подмножеством другого
- `issuperset()` - Для определения, является ли одно из множеств надмножеством другого
- `isdisjoint()` - Для определения отсутствия общих элементов в множествах
Операторы >, <, >=, <= требуют наличия в качестве операндов множеств.


### Для удаления элементов из множества используются методы:

Myset.remove() - удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.
Myset.discard() – удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует.
Myset.pop() - удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества.
Myset.clear() – удаляет все элементы из множества

### Объединение множеств (Оператор | )
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/union.png) 

`A | B  A.union(B)` -  Возвращает множество, являющееся объединением множеств A и B

`A |= B  A.update(B)` - Добавляет в множество A все элементы из множества B

### Пересечение множеств (Оператор &)
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/intersection.png) 

`A & B A.intersection(B)` -  Возвращает множество, являющееся пересечением множеств A и B

`A &= B  A.intersection_update(B)` - Оставляет в множестве A только те элементы, которые есть в множестве B

### Разность множеств (Оператор  - )
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/difference.png) 

`A - B   A.difference(B)` -  Возвращает разность множеств A и B

`A -= B   A.difference_update(B)` - Удаляет из множества A все элементы, входящие в B

### Симметрическая разность (Оператор ^ )
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/symmetric_difference.png) 

`A ^ B   A.symmetric_difference(B)` -  Возвращает симметрическую разность множеств A и B

`A ^= B   A.symmetric_difference_update(B)` - Записывает в A симметрическую разность множеств A и B
|  |  |  |
|  -----------  | ----------- | ----------- |  
| set1 <= set2 | set1.issubset(set2)	| Возвращает True, если set1 является подмножеством set2 |
| set1 >= set2 | set1.issuperset(set2) |	Возвращает True, если set1 является надмножеством set2 |
| set1 < set2	 ||  Эквивалентно set1 <= set2 and set1 != set2 (строгое подмножество) |
| set1 > set2 ||  	Эквивалентно set1 >= set2 and set1 != set2 (строгое надмножество) |

### Генератор множеств
```
squares = {i ** 2 for i in range(10)}
```
## Замороженное множество (frozenset) 
Также является встроенной коллекцией в Python. Обладая характеристиками обычного множества, замороженное множество не может быть изменено после создания.
•	объединение множеств: метод union() или оператор |;
•	пересечение множеств: метод intersection() или оператор &;
•	разность множеств: метод difference() или оператор -;
•	симметрическая разность множеств: метод symmetric_difference() или оператор ^.

Методы изменяющие множество отсутствуют у замороженных множеств:
- add()
- remove()
- discard()
- pop()
- clear()
- update()
- intersection_update()
- difference_update()
- symmetric_difference_update()


## Словари (dict)
Изменяемые коллекции элементов с произвольными индексами – ключами (Как списки, только вместо [ 0] обращение к словарю my_dict[key])
Примечание 1. Обращение по индексу и срезы недоступны для словарей.
Примечание 2. Операция конкатенации + и умножения на число * недоступны для словарей.

Словари нужно использовать в следующих случаях:
-	Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи — названия объектов, а значения — их количество.
-	Хранение каких-либо данных, связанных с объектом. Ключи — наименования объектов, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря num = {'January': 1, 'February': 2, 'March': 3, ...}.
-	Установка соответствия между объектами (например, “родитель—потомок”). Ключ — объект, значение — соответствующий ему объект.
-	Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “разреженный список”), то для экономии памяти можно использовать словарь.
Ключом словаря могут быть данные любого неизменяемого типа:
-	число;
-	строка;
-	булево значение;
-	кортеж;
-	замороженное множество (frozenset);
-	...
Значения – к любому типу данных

```
languages = {'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг', 'C++': 'Бьёрн Страуструп'} print('Создателем языка C# является', languages['C#'])
```

### Методы списков
Поддерживает функции len(), sum(), min(), max()
- `my_dict.fromkeys()` – если необходимо создать словарь с множеством ключей у одного значения 
- `my_dict.zip()` – создает словарь на основании 2 списков (кортежей)
- `my_dict.keys()` – возвращает список ключей всех элементов словаря
- `my_dict.values()` - возвращает список значений всех элементов словаря.
- `my_dict.items()` - возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение)
- `my_dict.sorted()` – сортировка по ключам.
- `my_dict.sorted().items()` - сортировка по значениям.
Стоит учитывать, что sorted(capitals.items(), key= lambda x: x[1]) возвращает не словарь, а отсортированный по значению список кортежей.
Словарные методы `items()`, `keys()`, `values()` возвращают не совсем обычные списки. Типы этих списков -  dict_items, dict_keys, dict_values соответственно, в отличие от обычных списков - list. Методы обычных списков недоступны для списков типа dict_items, dict_keys, dict_values. Используйте явное преобразование с помощью функции list() для получения доступа к методам списков.
My_dict.update()  - объединяет ключи и значения одного словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в качестве аргумента метода.

### Добавление и изменение элементов в словаре
Чтобы изменить значение по определенному ключу в словаре, достаточно использовать индексацию вместе с оператором присваивания. Если ключ уже присутствует в словаре, его значение заменяется новым, если же ключ отсутствует, то в словарь будет добавлен новый элемент.
- my_dict.get(key, default) – возвращает значение ключа key, если ключ находится в словаре, если ключ отсутствует, то вернет значение  default. Если Default не задан, вернет None. Ошибки не будет, если у ключа нет.
- my_dict.setdefault(key, default) - позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует.
  - key -  ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
  - default - значение, которое будет использовано при добавлении нового элемента в словарь.
В зависимости от значений параметров key и default возможны следующие сценарии работы данного метода.
Сценарий 1. Если ключ key присутствует в словаре, то метод возвращает значение по заданному ключу (независимо от того, передан параметр default или нет).
Сценарий 2. Если ключ key отсутствует в словаре, то метод вставляет переданное значение default по заданному ключу. При этом если значение default не передано в метод, то вставится значение  None.
`del` - удаляет элементы словаря по определенному ключу вместе со значением. Если ключа в словаре нет, возникнет ошибка KeyError.
`my_dict.pop()` – Возвращает значение удаляемого элемента. Если ключа в словаре нет, возникнет ошибка KeyError. (то же что и del, но возвращает значение). Чтобы ошибка не появлялась, этому методу можно передать второй аргумент. Он будет возвращен, если указанного ключа в словаре нет. Это позволяет реализовать безопасное удаление элемента из словаря:
```
surname = info.pop(‘surname’, None)
```

Если ключа surname в словаре нет, то в переменной surname будет храниться значение None.
popitem() - удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа (ключ, значение).
clear() -  удаляет все элементы из словаря.
copy() -  создает поверхностную копию словаря.
Примечание 1. Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — хеш-таблица. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.
Примечание 2. В рамках одного словаря каждый ключ уникален.
Примечание 3. Словари удобно использовать для хранения различных сущностей. Например, если нужно работать с информацией о человеке, то можно хранить все необходимые сведения, включающие такие разные сущности как "возраст", "профессия", "название города", "адрес электронной почты" в одном словаре  info и легко обращаться к его элементам по ключам:
   


 




