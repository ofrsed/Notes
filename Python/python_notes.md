# Python

## Типы данных
| Сокр |Тип рус | Характеристика | Упорядоченность | 
|  -----------  | ----------- | ----------- | ----------- | 
Int | Целое | Неизменяемые |  | 
|  | Комплексное | Неизменяемые |  | 
|  | Вещественное | Неизменяемые |  | 
| Str | Строки | Неизменяемые | Упорядоченные | 
| list | Списки | Изменяемые | Упорядоченные | 
| tuple | кортеж | Неизменяемые | Упорядоченные | 
| dict| словарь | Изменяемые | Упорядоченные | 
| set | Множество | Изменяемые | Упорядоченные | 
| bool | Булевое значение | Незменяемые | Упорядоченные | 


## Строки
### Методы строк
Метод — функция, применяемая к объекту. Метод вызывается в виде: 
`имя_объекта.имя_метода(параметры)`
- `x.capitalize()` – возвращает копию строки, в которой первый символ имеет верхний регистр, а остальные нижний
- `x.swapcase()` – возвращает копию строки, в которой все символы меняют регистр на противоположный
- `x.title()` – возвращает копию строки, в которой первый символ каждого слова переводится в  верхний регистр
- `x.lower()` – возвращает копию строки, в которой все символы имеют нижний регистр 
- `x.upper()` – возвращает копию строки, в которой все символы имеют верхний регистр 
- `x.count(<sub>,<start>,<end>)` – считает количество непересекающихся вхождений подстроки `<sub>` в строку
- `x.startswith(\<suffix>,\<start>,\<end>)` – определяет, начинается ли строка подстрокой `<suffix>`. Если начинается, возвращает значение  True, если нет – False
- `x.endswith(<suffix>,<start>,<end>)` – определяет, оканчивается ли строка подстрокой `<suffix>`. Если оканчивается, возвращает значение  True, если нет – False
- `x.find(<sub>,<start>,<end>)` – находит индекс первого вхождения подстроки `<sub>`. Если `<sub>` не встречается, выдает значение -1 
- `x.rfind(\<sub>,\<start>,\<end>)` – находит индекс первого вхождения подстроки <sub> с конца строки. Если <sub> не встречается, выдает значение -1 
- `x.index(\<sub>,\<start>,\<end>)` – идентичен x.find, за исключением если строка <sub> не найдена, выдает ошибку.
- `x.rindex(\<sub>,\<start>,\<end>)` – идентичен x.rfind, за исключением если строка <sub> не найдена, выдает ошибку.
- `x.strip()` – возвращает копию строки, в которой удалены все пробелы в начале и в конце строки.
- `x.lstrip()` – возвращает копию строки, в которой удалены все пробелы в начале строки.
- `x.rstrip()` – возвращает копию строки, в которой удалены все пробелы в конце строки.
- `x.strip(),x.lstrip()x.rstrip()` – могут принимать аргумент <chars>, определяющей набор символов для удаления.
- `x.replace(\<old>,\<new>,\<count>)` – возвращает копию строки, со всеми значениями \<old> замененными на <new>, \<count> определяет количество замен.
- `x.isalnum()` – определяет, состоит ли строка из букв или цифр. Возвращает True если строка является не пустой и состоит из букв и цифр, False в противном случае.
- `x.isalpha()` – определяет, состоит ли строка из букв. Возвращает True если строка является не пустой и состоит из букв, False в противном случае.
- `x.isdigit()` – определяет, состоит ли строка из цифр. Возвращает True если строка является не пустой и состоит из цифр, False в противном случае.
- `x.islower()` – определяет, являются ли все буквы строчными (нижний регистр), если все буквы имеют нижний регистр, выдает True, в противном случае выдает False. Все не алфавитные символы игнорируются.
- `x.isupper()` – определяет, являются ли все буквы заглавными (верхний регистр), если все буквы имеют верхний регистр, выдает True, в противном случае выдает False. Все не алфавитные символы игнорируются.
- `x.isspase()` – определяет состоит ли строка только из пробелов. Если строка только из пробелов, выдает True, в противном случае выдает False
- `num = ord()` – определяет код одного символа в таблице символов Unicode.
- `num = crh()` – определяет по числу  сам символ.

## Списки
Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.
### Методы списков
- `List()` – помимо создания пустого списка может преобразовывать некоторые типы объектов в списки
- `x.append()` – добавляет элемент в конец списка
- `x.extend()` – расширяет список другим списком
- `del x[]` – удаляет элемент списка по индексу
- `x.split(“ “)` – разбивает строку на слова, используя пробел в качестве разделителя (можно менять)
- `‘*‘.join.(x)` – собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод
- `x.insert(<index>,<value>)` – вставляет на  <index> значение <value>
- `x.index(<value>, <start>,<end>)` – возвращает индекс первого элемента, указанного значения
- `x.remove(<value>)` – удаляет первый элемент в списке, имеющий значение <value>. Если значения нет, выдает ошибку
- `x.pop(<index>)` – удаляет <index>, и возвращает его. Если <index> не указан, удаляет последний элемент
- `x.count(<value>)` – возвращает количество элементов со значением  <value>
- `x.reverse()` – разворачивает список
- `x.copy()` – копия списка
- `x.clear()` – очищает список
- `x.sort()` – сортирует исходный список по возрастанию, изменяет индексы, возвращает None
- `sorted(x)` – возвращает новый отсортированный список, исходный без изменений
- `x.sort(reverse=True)` – сортирует по убыванию


## Кортежы
Кортеж – неизменяемый последовательность символов (Неизменяемые аналоги списков)
`My_tuple = (1,)` – кортеж с одним элементом
Преимущества кортежей:
- скорость (работают быстрее, т.к. из-за неизменяемости хранятся в памяти иначе. Одна из причин сущствования кортежей – производительность. Обработка происходит быстрее, поэтому удобны для большого объема неизменяемых данных.
- безопасность (можно безопвсно хранить данные, не опасаясь что они будут случайно или преднамеренно изменены в программе)
Поддерживают:
-доступ к элементу по индексу (только для получения значений элементов);
-методы, в частности index(), count();
-встроенные функции, в частности len(), sum(), min() и max();
-срезы;
-оператор принадлежности in;
-операторы конкатенации (+) и повторения (*)
-а т.к. не изменяемые, не поддерживают sort(), которые меняют порядок, но поддерживают sorted()
преобразуются в строку с помощью “”.join()

Распаковка:
```
colors = ('red', 'green', 'blue', 'cyan')
 a, b, c, d = colors
```

Распаковка со звездочкой посередине

```
singer = ('one', 'two', 'three', 'four', 'five')
 name, *songs, surname = singer print(name) print(songs) print(surname)
```

Выводит:
one ['two', 'three', 'four'] five


## Булевые значения
True == 1
False == 0
None 

Для сравнения с None нужно использовать оператор не ==, а is, чтобы небыло проблем с типами

## Множества
Set() – пустое множество
Совокупность объектов, понимаемых как единое целое (множество студентов, множество натуральных чисел)  
Важно знать:
Элементы множества – любые неизменяемые 
•	все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
•	множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
•	элементы множества должны относиться к неизменяемым типам данных;
•	хранящиеся в множестве элементы могут иметь разные типы данных
•	Индексация и срезы недоступны для множеств.
•	Операция конкатенации + и умножения на число * недоступны для множеств
•	При выводе порядок множества порядок меняется произвольным способом
 
Методы множеств:
Встроенные функции len(), sum(), min(), max()
myset.add() - добавляет новый элемент в множество.

### Для удаления элементов из множества используются методы:

Myset.remove() - удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.
Myset.discard() – удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует.
Myset.pop() - удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества.
Myset.clear() – удаляет все элементы из множества


![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/union.png) 

| A \| B \|A.union(B) | Возвращает множество, являющееся объединением множеств A и B |
| A \|= B A.update(B) | Добавляет в множество A все элементы из множества B |
