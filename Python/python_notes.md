# Python
- [Теория](#Теория)
- [Строки](#Строки)
- [Списки](#Списки)
- [Кортежы](#Кортежы)
- [Булевые значения](#Булевые-значения)
- [Множества](#Множества)
- [Словари](#Словари)
- [Функции](#Функции)
- [Кортежи](#Кортежы)
- [Итератор](#Итератор)


## Теория
### Типизация языков программирования
Типизация языков программирования — это то, как различные языки распознают типы переменных.
Языки бывают:
-Не типизированными (беспиповыми)
-Типизированными
Нетипизированные языки программирования (Assembler, Forth, Brainfuck и т.д.)
Типизированные языки программирования (C,Python, Scala, PHP, Lua, C#, Java и т. д.)

Бестиповая типизация присуща старым и низкоуровневым языкам. Все данные в таких языках считаются цепочками бит произвольной длины, и не делятся на типы.
Преимущества:
- позволяет писать на предельно низком уровне, интерпретатор не будет мешать проверками типов
- получаемый код более эффективен
- прозрачность инструкций, при знании языка код понятен
Недостатки:
- сложность: неудобство с типами строки / списки и т. д.
- отсутствие проверок
- низкий уровень абстракции

### Статическая и динамическая типизация
Статическая типизация (C, Java,C#, Kotlin, Scala, GO и т.д.)
В таких языках проверка типов начинается на стадии компиляции. Компиляторы ищут ошибку еще до запуска программы. Благодаря этому они работают быстрее, кроме того тип для переменной можно назначить только один раз
Преимущества:
- Проверка типов только один раз — на этапе компиляции
- Скорость выполнения
- Ускорение разработки при поддержки IDE
Динамическая типизация (Python, JavaScript, Ruby, Julia и т. д.)
	Ищут ошибки на стадии выполнения, Они более гибкие, в них можно задать разные типы для одной переменной
Преимущества:
- Простота создания универсальных коллекций
- Удобство описания обобщенных алгоритмов (сортировка работает не только со списком)
- Легкость в освоении

### Сильная (строгая) и слабая (нестрогая) типизация
Сильная (строгая) типизация (Java, Python, Haskell, Lisp и т. д.)
При строгой типизации язык не позволяет смешивать разные типы данных
Преимущества:
- Надежность. Получаем ошибки при неправильно поведении
- Скорость. Знаем какие участки работают медленнее
- Понимание работы программы
- Определенность. Мы знаем что и во что мы преобразуем

Слабая (нестрогая) типизация (С, JavaScript, Visual Basic, PHP и т.д.) 
В слабо типизированных языках можно смешивать разные типы данных (int + str), Так код получается короче
Преимущества:
- Удобство использование смешанных выражений
- Абстрагирование от типизации с сосредоточение на задаче
- Краткость записи


### Явная и неявная типизация
Явная типизация (C++, D, C#, Java и т. д.)
В языках с явной типизацией нужно явно указывать тип данных (int data = 17)
Преимущества:
- Наличие у каждой функции сигнатуры, что позволяет без проблем определить что она делает
- Снимает необходимость запоминать тип переменной
Неявная типизация ((Python, PHP, Lua, JavaScript и т. д.)
В языках с неявной типизацией тип переменной определяется компилятором (x = 17)
Преимущества:
- Сокращение записи
- Устойчивость к изменениям




## Типы данных
| Сокр |Тип рус | Характеристика | Упорядоченность | 
|  -----------  | ----------- | ----------- | ----------- | 
Int | Целое | Неизменяемые |  | 
|  | Комплексное | Неизменяемые |  | 
|  | Вещественное | Неизменяемые |  | 
| Str | Строки | Неизменяемые | Упорядоченные | 
| list | Списки | Изменяемые | Упорядоченные | 
| tuple | кортеж | Неизменяемые | Упорядоченные | 
| dict| словарь | Изменяемые | Упорядоченные | 
| set | Множество | Изменяемые | Упорядоченные | 
| bool | Булевое значение | Незменяемые | Упорядоченные | 


## Строки
### Методы строк
Метод — функция, применяемая к объекту. Метод вызывается в виде: 
`имя_объекта.имя_метода(параметры)`
- `x.capitalize()` – возвращает копию строки, в которой первый символ имеет верхний регистр, а остальные нижний
- `x.swapcase()` – возвращает копию строки, в которой все символы меняют регистр на противоположный
- `x.title()` – возвращает копию строки, в которой первый символ каждого слова переводится в  верхний регистр
- `x.lower()` – возвращает копию строки, в которой все символы имеют нижний регистр 
- `x.upper()` – возвращает копию строки, в которой все символы имеют верхний регистр 
- `x.count(<sub>,<start>,<end>)` – считает количество непересекающихся вхождений подстроки `<sub>` в строку
- `x.startswith(\<suffix>,\<start>,\<end>)` – определяет, начинается ли строка подстрокой `<suffix>`. Если начинается, возвращает значение  True, если нет – False
- `x.endswith(<suffix>,<start>,<end>)` – определяет, оканчивается ли строка подстрокой `<suffix>`. Если оканчивается, возвращает значение  True, если нет – False
- `x.find(<sub>,<start>,<end>)` – находит индекс первого вхождения подстроки `<sub>`. Если `<sub>` не встречается, выдает значение -1 
- `x.rfind(\<sub>,\<start>,\<end>)` – находит индекс первого вхождения подстроки <sub> с конца строки. Если <sub> не встречается, выдает значение -1 
- `x.index(\<sub>,\<start>,\<end>)` – идентичен x.find, за исключением если строка <sub> не найдена, выдает ошибку.
- `x.rindex(\<sub>,\<start>,\<end>)` – идентичен x.rfind, за исключением если строка <sub> не найдена, выдает ошибку.
- `x.strip()` – возвращает копию строки, в которой удалены все пробелы в начале и в конце строки.
- `x.lstrip()` – возвращает копию строки, в которой удалены все пробелы в начале строки.
- `x.rstrip()` – возвращает копию строки, в которой удалены все пробелы в конце строки.
- `x.strip(),x.lstrip()x.rstrip()` – могут принимать аргумент <chars>, определяющей набор символов для удаления.
- `x.replace(\<old>,\<new>,\<count>)` – возвращает копию строки, со всеми значениями \<old> замененными на <new>, \<count> определяет количество замен.
- `x.isalnum()` – определяет, состоит ли строка из букв или цифр. Возвращает True если строка является не пустой и состоит из букв и цифр, False в противном случае.
- `x.isalpha()` – определяет, состоит ли строка из букв. Возвращает True если строка является не пустой и состоит из букв, False в противном случае.
- `x.isdigit()` – определяет, состоит ли строка из цифр. Возвращает True если строка является не пустой и состоит из цифр, False в противном случае.
- `x.islower()` – определяет, являются ли все буквы строчными (нижний регистр), если все буквы имеют нижний регистр, выдает True, в противном случае выдает False. Все не алфавитные символы игнорируются.
- `x.isupper()` – определяет, являются ли все буквы заглавными (верхний регистр), если все буквы имеют верхний регистр, выдает True, в противном случае выдает False. Все не алфавитные символы игнорируются.
- `x.isspase()` – определяет состоит ли строка только из пробелов. Если строка только из пробелов, выдает True, в противном случае выдает False
- `num = ord()` – определяет код одного символа в таблице символов Unicode.
- `num = crh()` – определяет по числу  сам символ.

## Списки
Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.
### Методы списков
- `List()` – помимо создания пустого списка может преобразовывать некоторые типы объектов в списки
- `x.append()` – добавляет элемент в конец списка
- `x.extend()` – расширяет список другим списком
- `del x[]` – удаляет элемент списка по индексу
- `x.split(“ “)` – разбивает строку на слова, используя пробел в качестве разделителя (можно менять)
- `‘*‘.join.(x)` – собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод
- `x.insert(<index>,<value>)` – вставляет на  <index> значение <value>
- `x.index(<value>, <start>,<end>)` – возвращает индекс первого элемента, указанного значения
- `x.remove(<value>)` – удаляет первый элемент в списке, имеющий значение <value>. Если значения нет, выдает ошибку
- `x.pop(<index>)` – удаляет <index>, и возвращает его. Если <index> не указан, удаляет последний элемент
- `x.count(<value>)` – возвращает количество элементов со значением  <value>
- `x.reverse()` – разворачивает список
- `x.copy()` – копия списка
- `x.clear()` – очищает список
- `x.sort()` – сортирует исходный список по возрастанию, изменяет индексы, возвращает None
- `sorted(x)` – возвращает новый отсортированный список, исходный без изменений
- `x.sort(reverse=True)` – сортирует по убыванию


## Кортежы
Кортеж – неизменяемый последовательность символов (Неизменяемые аналоги списков)
`My_tuple = (1,)` – кортеж с одним элементом
Преимущества кортежей:
- скорость (работают быстрее, т.к. из-за неизменяемости хранятся в памяти иначе. Одна из причин сущствования кортежей – производительность. Обработка происходит быстрее, поэтому удобны для большого объема неизменяемых данных.
- безопасность (можно безопвсно хранить данные, не опасаясь что они будут случайно или преднамеренно изменены в программе)
Поддерживают:
-доступ к элементу по индексу (только для получения значений элементов);
-методы, в частности index(), count();
-встроенные функции, в частности len(), sum(), min() и max();
-срезы;
-оператор принадлежности in;
-операторы конкатенации (+) и повторения (*)
-а т.к. не изменяемые, не поддерживают sort(), которые меняют порядок, но поддерживают sorted()
преобразуются в строку с помощью “”.join()

Распаковка:
```
colors = ('red', 'green', 'blue', 'cyan')
 a, b, c, d = colors
```

Распаковка со звездочкой посередине

```
singer = ('one', 'two', 'three', 'four', 'five')
 name, *songs, surname = singer print(name) print(songs) print(surname)
```

Выводит:
one ['two', 'three', 'four'] five


## Булевые значения
True == 1
False == 0
None 

Для сравнения с None нужно использовать оператор не ==, а is, чтобы небыло проблем с типами

## Множества
Set() – пустое множество

Совокупность объектов, понимаемых как единое целое (множество студентов, множество натуральных чисел)  

### Важно знать:
•	Элементы множества – любые неизменяемые 
•	все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
•	множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
•	элементы множества должны относиться к неизменяемым типам данных;
•	хранящиеся в множестве элементы могут иметь разные типы данных
•	Индексация и срезы недоступны для множеств.
•	Операция конкатенации + и умножения на число * недоступны для множеств
•	При выводе порядок множества порядок меняется произвольным способом
 
### Методы множеств:
Встроенные функции len(), sum(), min(), max()
- `myset.add()` - добавляет новый элемент в множество.
- `issubset()` - Для определения, является ли одно из множеств подмножеством другого
- `issuperset()` - Для определения, является ли одно из множеств надмножеством другого
- `isdisjoint()` - Для определения отсутствия общих элементов в множествах
Операторы >, <, >=, <= требуют наличия в качестве операндов множеств.


### Для удаления элементов из множества используются методы:

Myset.remove() - удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.
Myset.discard() – удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует.
Myset.pop() - удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества.
Myset.clear() – удаляет все элементы из множества

### Объединение множеств (Оператор | )
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/union.png) 

`A | B  A.union(B)` -  Возвращает множество, являющееся объединением множеств A и B

`A |= B  A.update(B)` - Добавляет в множество A все элементы из множества B

### Пересечение множеств (Оператор &)
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/intersection.png) 

`A & B A.intersection(B)` -  Возвращает множество, являющееся пересечением множеств A и B

`A &= B  A.intersection_update(B)` - Оставляет в множестве A только те элементы, которые есть в множестве B

### Разность множеств (Оператор  - )
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/difference.png) 

`A - B   A.difference(B)` -  Возвращает разность множеств A и B

`A -= B   A.difference_update(B)` - Удаляет из множества A все элементы, входящие в B

### Симметрическая разность (Оператор ^ )
![Image alt](https://github.com/ofrsed/Notes/blob/main/Python/symmetric_difference.png) 

`A ^ B   A.symmetric_difference(B)` -  Возвращает симметрическую разность множеств A и B

`A ^= B   A.symmetric_difference_update(B)` - Записывает в A симметрическую разность множеств A и B
|  |  |  |
|  -----------  | ----------- | ----------- |  
| set1 <= set2 | set1.issubset(set2)	| Возвращает True, если set1 является подмножеством set2 |
| set1 >= set2 | set1.issuperset(set2) |	Возвращает True, если set1 является надмножеством set2 |
| set1 < set2	 ||  Эквивалентно set1 <= set2 and set1 != set2 (строгое подмножество) |
| set1 > set2 ||  	Эквивалентно set1 >= set2 and set1 != set2 (строгое надмножество) |

### Генератор множеств
```
squares = {i ** 2 for i in range(10)}
```
## Замороженное множество (frozenset) 
Также является встроенной коллекцией в Python. Обладая характеристиками обычного множества, замороженное множество не может быть изменено после создания.
•	объединение множеств: метод union() или оператор |;
•	пересечение множеств: метод intersection() или оператор &;
•	разность множеств: метод difference() или оператор -;
•	симметрическая разность множеств: метод symmetric_difference() или оператор ^.

Методы изменяющие множество отсутствуют у замороженных множеств:
- add()
- remove()
- discard()
- pop()
- clear()
- update()
- intersection_update()
- difference_update()
- symmetric_difference_update()


## Словари
Изменяемые коллекции элементов с произвольными индексами – ключами (Как списки, только вместо [ 0] обращение к словарю my_dict[key])
Примечание 1. Обращение по индексу и срезы недоступны для словарей.
Примечание 2. Операция конкатенации + и умножения на число * недоступны для словарей.

Словари нужно использовать в следующих случаях:
-	Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи — названия объектов, а значения — их количество.
-	Хранение каких-либо данных, связанных с объектом. Ключи — наименования объектов, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря num = {'January': 1, 'February': 2, 'March': 3, ...}.
-	Установка соответствия между объектами (например, “родитель—потомок”). Ключ — объект, значение — соответствующий ему объект.
-	Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “разреженный список”), то для экономии памяти можно использовать словарь.
Ключом словаря могут быть данные любого неизменяемого типа:
-	число;
-	строка;
-	булево значение;
-	кортеж;
-	замороженное множество (frozenset);
-	...
Значения – к любому типу данных

```
languages = {'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг', 'C++': 'Бьёрн Страуструп'} print('Создателем языка C# является', languages['C#'])
```

### Методы списков
Поддерживает функции len(), sum(), min(), max()
- `my_dict.fromkeys()` – если необходимо создать словарь с множеством ключей у одного значения 
- `my_dict.zip()` – создает словарь на основании 2 списков (кортежей)
- `my_dict.keys()` – возвращает список ключей всех элементов словаря
- `my_dict.values()` - возвращает список значений всех элементов словаря.
- `my_dict.items()` - возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение)
- `my_dict.sorted()` – сортировка по ключам.
- `my_dict.sorted().items()` - сортировка по значениям.
Стоит учитывать, что sorted(capitals.items(), key= lambda x: x[1]) возвращает не словарь, а отсортированный по значению список кортежей.
Словарные методы `items()`, `keys()`, `values()` возвращают не совсем обычные списки. Типы этих списков -  dict_items, dict_keys, dict_values соответственно, в отличие от обычных списков - list. Методы обычных списков недоступны для списков типа dict_items, dict_keys, dict_values. Используйте явное преобразование с помощью функции list() для получения доступа к методам списков.
My_dict.update()  - объединяет ключи и значения одного словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в качестве аргумента метода.

### Добавление и изменение элементов в словаре
Чтобы изменить значение по определенному ключу в словаре, достаточно использовать индексацию вместе с оператором присваивания. Если ключ уже присутствует в словаре, его значение заменяется новым, если же ключ отсутствует, то в словарь будет добавлен новый элемент.
- my_dict.get(key, default) – возвращает значение ключа key, если ключ находится в словаре, если ключ отсутствует, то вернет значение  default. Если Default не задан, вернет None. Ошибки не будет, если у ключа нет.
- my_dict.setdefault(key, default) - позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует.
  - key -  ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
  - default - значение, которое будет использовано при добавлении нового элемента в словарь.
В зависимости от значений параметров key и default возможны следующие сценарии работы данного метода.
Сценарий 1. Если ключ key присутствует в словаре, то метод возвращает значение по заданному ключу (независимо от того, передан параметр default или нет).
Сценарий 2. Если ключ key отсутствует в словаре, то метод вставляет переданное значение default по заданному ключу. При этом если значение default не передано в метод, то вставится значение  None.
`del` - удаляет элементы словаря по определенному ключу вместе со значением. Если ключа в словаре нет, возникнет ошибка KeyError.
`my_dict.pop()` – Возвращает значение удаляемого элемента. Если ключа в словаре нет, возникнет ошибка KeyError. (то же что и del, но возвращает значение). Чтобы ошибка не появлялась, этому методу можно передать второй аргумент. Он будет возвращен, если указанного ключа в словаре нет. Это позволяет реализовать безопасное удаление элемента из словаря:
```
surname = info.pop(‘surname’, None)
```

Если ключа surname в словаре нет, то в переменной surname будет храниться значение None.
popitem() - удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа (ключ, значение).
clear() -  удаляет все элементы из словаря.
copy() -  создает поверхностную копию словаря.
Примечание 1. Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — хеш-таблица. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.
Примечание 2. В рамках одного словаря каждый ключ уникален.
Примечание 3. Словари удобно использовать для хранения различных сущностей. Например, если нужно работать с информацией о человеке, то можно хранить все необходимые сведения, включающие такие разные сущности как "возраст", "профессия", "название города", "адрес электронной почты" в одном словаре  info и легко обращаться к его элементам по ключам:
   


 
## Функции
Можно передавать в функцию именованный и неименованный переменные
Аргументы функции, передаваемые без указания имен – позиционные
Аргументы с именами – именованные
Примечания: 
-при написании функции стоит указывать более важные параметры первыми.
-параметр в програмировании – принятый функцией аргумент. Термин «аргумент» подразумевает, что конкретно к какой конкретной функции было передано, а параметр – в каком качестве функция применила это принятое. То есть вызывабщий код передает аргумент в параметр, который определен в описании (заголовке) функции
Parameter – Placeholder ( заполнитель принадлежит имени функции и используется в теле функции)
Argument – Actual value (фактическое значение, которое передается при вызове функции.

```
Def my_func(a, b, *args, name=”Gvido”,  age=17,  **kwargs) – правильное расположение аргументов
    name=”Gvido” – значение по умолчанию, если не передается значение – остается заданное
*args – функция получает в виде кортежа все переданные в нее аргументы
**kwargs – функция получает в виде списка все переданные в нее аргументы
    append.__defaults__ - посмотреть в функции значение по умолчанию
```

- `Map(func, *iterables)` – берет каждый элемент итерируемого объекта *iterables, обрабатывает при помощи функции funk и возвращает итератор. В *iterables можно передать несколько объектов, последовательность с минимальным количеством элементов становится ограничителем. Потребляет мало памяти (возвращает ленивый итератор), и написана на языке C, эффективнее for

- `filter(func, iterable)` - внутри функции func необходимо вернуть значение True или False. Возвращает итератор. В итоговый итератор попадает только тот элемент последовательности, который возвращает True. Если func = None — тогда в результат попадут значения, которые True. Потребляет мало памяти (возвращает ленивый итератор), и написана на языке C, эффективнее for

- `emunerate(iterable, start=0)` — нумерует элементы итерируемого объекта iterable, начиная со значения start. Возвращает кортеж. По умолчанию нумерация с нуля. Возвращает итератор

- `zip(*iterables, strict=False)`  - объединяет элементы каждого из переданных итерируемых объектов *iterables. Возвращает кортеж, где i-й кортеж содержит i-й элемент из каждого итерируемого объекта. По умолчанию strict=False — т. е. Функция останавливается, когда исчерпывается самый короткий итерируемый объект. Если True — проверяет длины объектов, и при несовпадении возбуждает ошибку ValueError. С одним аргументом вовзращает итератор из кортежей с одним элементом, без аргументов возвращает пустой итератор. Потребляет мало памяти. Возвращает итератор

- `reversed(seq)` — перебирает элементы итерируемого объекта в обратном порядке. Возвращает итератор





From functools import reduce
Reduce(func, iterable, initializer=None) – агрегирует результат формированием одного результирующего значение при комбинации элементов с использованием аргумента-аккумулятора. (Например сумма всех элементов или произведение) Если начальное значение не установлено, то в его качестве первое значение из последовательности iterable

All(iterable) – Если в последовательности есть хотя бы один False – возвращает False. Если все значения True – Возвращает True.  Если передать один пустой объект ([], (), “”,) – Выводит True
Print ( all ( [] ) )  # передаем пустой список. Выводит: True
Print ( all ( () ) ) # передаем пустой кортеж. Выводит: True
Print ( all ( “ “ ) ) # передаем пустую строку. Выводит: True
Print ( all ( [ [], [] ] ) ) # передаем список, содержащий пустые списки. Выводит False

any(iterable) – Ищет хотя бы одно True, если находит – возвращает True, если все значения False – возвращает False
print ( any ( [ ] ) ) # передаем пустой список, выводит: False
print ( any ( ( ) ) ) # передаем пустой кортеж, выводит: False
print ( any ( “ “ ) ) # передаем пустую строку, выводит: False
print ( any ( [ [ ] , [ ] ] ) ) # передаем список, содержащий пустые списки, выводит: False

Функции all() и any() могут быть полезны в комбинации с функцией map(), которая может преобразовывать элементы последовательности (итерируемого объекта) к значению True/False в соответствии с неким условием. Например, если все элементы списка numbers больше 10:
Result = all(map(lambda x: x > 10, numbers))
Хотя бы одно число:
Result = any(map(lambda x: x % 2 == 0, numbers))
Enumerate(iterable, start) – возвращает итератор ,из кортежей (индекса элемента, и самого элемента). Start – необязательный параметр, задает начальное значение индекса. (По умолчанию start = 0)
Zip ( *iterables) – объединяет элементы из каждого переданного ей итерируемого объекта в кортежи. Возвращает итератор из кортежей. Длина определяется объектом с минимальной длиной, используется для создания словарей, когда ключи и значения в разных списках.
Info = dict (zip (keys, values ) )
 
Модуль operator
| Операция  |	Синтаксис |	Функция |
|  -----------  | ----------- | ----------- |
| Addition |	a + b	| add ( a , b) |
| Containment |	Test	obj in seq |	contains ( seq, obj ) |
| Division |	a / b |	truediv (a , b ) |
| Division |	a // b |	floordiv (a , b ) |
| Exponentiation |	a ** b |	pow (a , b ) |
| Modulo |	a % b |	mod ( a , b ) |
| Multiplication |	a * b |	mul ( a , b ) |
| Negation (Arithmetic) |	- a |	neg ( a ) |
| Subtraction |	a – b |	sum ( a , b ) |
| Ordering |	a < b |	lt ( a , b ) |
| Ordering |	a < = b |	le ( a , b ) |
| Equality |	a == b |	eq ( a , b ) |
| Difference |	a != b |	ne( a , b ) |
| Ordering |	a > = b |	ge ( a , b ) |
| Ordering |	a > b |	gt ( a < b ) |



Подучить 
“”,join()
Decimal, fraction
F’ строки
Min, max, sort принимают аргумент key, в котором можно key=len, abs. . функция берет один элемент из списка, и кидает ее в функцию.
def func_min(num):
    return sum(num) / len(num)
isinstance(x, int), x – вернет Trueб если проверяемый обьект является экземпляром указанного класса или его подкласса

# Итератор

Итератор - объект, который реализует методы iter и next

# Генератор
