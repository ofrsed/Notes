
__Асинхронное программирование__ - Способ программирования, при котором можно выполнять множество задач конкурентно, не дожидаясь завершения предыдущей.

__Синхронный запрос__ - ожидает получения ответа перед тем, как перейти к следующей задаче

Преимущества асинхронности:
- Повышение производительности за счет неблокирующего ввода-вывода
- Возможность обработать больше запросов без увеличения количества аппаратных ресурсов

IO bound и CPU bound

IO bound - задачи, время выполнения которых в основном определяется временем выполнения всех операций ввода/вывода.
CPU bound - скорость выполнения зависит преимущественно от мощности процессора.

__GIL__

GIL - Глобальная блокировка интерпретатора. Это мьютекс (mutex), который предотвращает выполнение нескольких потоков в одно и то же время. GIL гарантирует, что только один поток выполняет Python-код в любой момент времени. Это нужно, чтобы вся программа работала без сбоев: чтобы данные не перепутались и память правильно очищалась после того, как объекты перестают быть нужны.

Вот как GIL работает:
1. При запуске интерпретатора Python создается GIL.
2. Когда создается поток, он действительно "знает" о существовании GIL, но не столько "связывается" с ним, сколько учитывает его в своей работе. Поток не всегда активно взаимодействует с GIL — это происходит только в моменты, когда он выполняет инструкции, изменяющие состояние Python-объектов.
3. Перед выполнением поток проверяет, не занят ли GIL другим потоком. Если GIL свободен, поток блокирует его для себя и начинает выполнение кода. Это предотвращает одновременное изменение объектов другими потоками.
4. Если GIL занят, поток ожидает его освобождения. Python использует механизмы планирования потоков операционной системы, а также внутреннюю логику для определения, когда потоку следует попытаться захватить GIL снова.
5. Во время выполнения поток действительно может освобождать GIL, особенно при операциях ввода-вывода или при использовании определенных функций, которые явно освобождают GIL (например, time.sleep()). Это позволяет другим потокам получить доступ к выполнению, улучшая отзывчивость программы при операциях, не требующих постоянного доступа к Python-объектам.
6. После завершения своей работы поток освобождает GIL, позволяя другим потокам захватить его и продолжить выполнение.

Взаимодействие Asyncio и GIL
В простых асинхронных приложениях с использованием asyncio все задачи выполняются внутри одного потока. Но при операциях ввода-вывода GIL освобождается. Именно этот факт использует asyncio, что позволяет внутри одного потока в момент ожидания переключаться с одной задачи на другую и реализовывать конкурентное выполнение задач. При этом asyncio полностью подчиняется GIL, так что при кажущемся параллелизме, задачи в асинхронном приложении выполняются по очереди, передавая управление друг другу при ожидании ответа на запрос. 

Как обойти GIL?
Чтобы не сталкиваться с проблемой GIL, есть несколько трюков. Во-первых, можно попробовать многопроцессное программирование вместо того, чтобы работать с потоками. Это значит, что вы запускаете несколько процессов, и каждый из них работает на своём ядре процессора. Так вы сможете использовать все ресурсы компьютера на полную катушку.

Если вам нужно много считать, можно воспользоваться специальными библиотеками, например, NumPy или pandas. Они написаны с использованием языка C и могут обходить GIL, выполняя тяжёлые задачи в отдельных потоках или процессах, что ускоряет работу.

# Awaitable объекты

Awaitable объект - это объекты, ожидающие результатов

- Корутина - это функции, которые могут быть приостановлены и возобновлены.

Кооперативная многозадачность - задачи сами решают, когда им следует уступить контроль другим задачам. 
Вытесняющая многозадачность - операционная система принимает решения о том, когда задаче следует начать или прекратить выполнение.

- Задачи Task - используются для одновременного планирования сопрограмм
- Future - это специальный низкоуровневый ожидаемый объект, представляющий собой конечный результат асинхронной операции.


await - это ключевое слово, которое используется для переключения между awaitable объектами.

# Общие методы asyncio:

#### asyncio.run()

- `asyncio.run(coro, *, debug=None, loop_factory=None)` - функция создаёт цикл событий и запускает указанную корутину в нём. После завершения выполнения coro автоматически закрывает цикл событий.
  - `coro` - Coroutine, которую нужно запустить.
  - `debug` - Логический флаг, указывающий, следует ли запускать цикл событий в режиме отладки. Если None, значение берется из глобальной настройки отладки
  - `loop_factory` - представляет собой вызываемый объект (функцию или класс с методом __call__), который возвращает экземпляр цикла событий. Это позволяет пользователям предоставлять свою реализацию цикла событий или настроенный экземпляр цикла событий, который может иметь определенные настройки или расширения 

Особенности:
1. Создает и закрывает цикл событий
2. В рамках потока вызывается один раз
3. asyncio.run() нельзя вызвать из корутины. Это приведет к ошибке, так как функцию нельзя вызывать, когда другой цикл событий asyncio уже работает в том же потоке.
4. Может быть использован только с корутинами
5. не гарантирует порядок выполнения асинхронных операций внутри main(). Операции вернут результат по факту своего завершения
6. Возвращает результат работы передаваемой корутины
7. Ошибка, вызванная в одной из корутин, будет проброшена в вызывающий код



## asyncio.sleep()

- `asyncio.sleep(delay, result=None)` - приостанавливает исполнение текущей корутины, позволяя циклу событий (event loop) обрабатывать другие корутины или задачи.
  - `delay` - Количество секунд на которое нужно приостановить выполнение.
  - `result` - Значение, которое sleep() вернет после завершения задержки
 
Особенности:
1. Не блокирует поток выполнения программы, а только приостанавливает выполнение текущей корутины
2. Не точный метод -  выполнение корутины может быть приостановлено на более длительное время из-за переключения между задачами

# Методы для создания, запуска и ожидания задач: 

## asyncio.create_task()

- `asyncio.create_task(coro, *, name=None, context=None)` - функция оборачивает coro в объект Task, т.е. она будет запланирована для выполнения в цикле событий.
  - `coro` - Coroutine для оборачивания в Task
  - `name` -  Имя задачи. Может быть использовано для удобства отладки
  - `context` - Контекст выполнения, который будет связан с задачей. Это может быть использовано для передачи контекстной информации между задачами.
 
Особенности:
1. При создании задача только планируется к выполнению, но не начинает выполняться сразу. Выполняться задача начнет при первом переключении контекста (await)
2. Созданную задачу нужно ожидать с ключевым словом await
3. Задачи можно создать в любом количестве.
4. Порядок создания задач с помощью asyncio.create_task() может не совпадать с порядком завершения задач. 
5. должна использоваться в контексте асинхронной функции, которая затем запускается с помощью asyncio.run()
6. Ошибка, вызванная в одной из корутин, не будет выброшена немедленно.
7. Задачи, созданные с помощью asyncio.create_task(), могут быть отменены. 
8. Если одна из задач зависает, то все остальные задачи также могут зависнуть. 

## asyncio.ensure_future()
- `asyncio.ensure_future(coro_or_future, *, loop=None)` - это функция, которая используется для запуска корутины в асинхронном режиме.
  - `coro_or_future` - Объект, который должен быть обработан. Может быть корутиной, объектом Future или Task или любым другим объектом, поддерживающим асинхронное ожидание.
  - `loop` - Цикл событий, на котором должна быть запланирована задача.
 
Особенности:
1. Работает с любыми awaitable объектами


## asyncio.gather()
- `asyncio.gather(*aws, return_exceptions=False)` - одновременно запускает объекты awaitable, переданные в функцию как последовательность *aws.
  - `*aws` -Последовательность awaitable объектов, которые должны быть выполнены конкурентно
  - `return_exceptions` - Первое появившееся исключение, немедленно распространяется на ту задачу, в которой оно возникло в момент ожидания asyncio.gather(). При этом другие объекты в последовательности aws не будут отменены и продолжат выполнение. Если True то исключения обрабатываются так же, как успешные результаты и передаются в совокупный список результатов.
 
Особенности:
1. Конкурентное выполнение задач
2. возвращает список из результатов задач в том же порядке, в каком они переданы
3. Гибкое управление исключениями
4. Ограничение на использование ресурсов

## asyncio.wait_for()
- `asyncio.wait_for()` -  функция ожидает завершения aw(awaitable объект) и, если выполнение не завершено в течение timeout секунд, переданный awaitable объект отменяется и вызывается TimeoutError
  - `aw` - Awaitable объект, завершение которого ожидается
  - `timeout` - Максимальное количество секунд ожидания. Если timeout достигнут, будет вызван TimeoutError. Если None, то ожидание будет бесконечным.
 
Особенности:
1. asyncio.wait_for() должна использоваться с ключевым словом await
2. возвращает то же значение, что и завершенная задача
3. принимает любой awaitable объект
4.  не блокирует цикл событий
5. Если awaitable не возвращает результат до истечения таймаута - происходит ошибка
6. asyncio.shield()
7. 

```
import asyncio


async def my_coro():
    await asyncio.sleep(5)
    return 'Привет мир!'


async def main():
    await asyncio.wait_for(my_coro(), timeout=3)


asyncio.run(main())
```


## asyncio.wait()
- `` -
  - `` -
  - `` -
 
Особенности:
1. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
## asyncio.shield()
- `` -
  - `` -
  - `` -
 
Особенности:
1. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
# Методы для работы с циклом событий:

## asyncio.new_event_loop()
## asyncio.set_event_loop(loop)
## loop.run_until_complete(future)
## asyncio.get_event_loop()
## asyncio.get_running_loop()

# Методы для работы асинхронных приложений в нескольких потоках:

## asyncio.run_coroutine_threadsafe()
## asyncio.to_thread()

- `` -
  - `` -
  - `` -
 
Особенности:
1. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
