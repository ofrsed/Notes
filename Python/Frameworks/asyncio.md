
__Асинхронное программирование__ - Способ программирования, при котором можно выполнять множество задач конкурентно, не дожидаясь завершения предыдущей.

__Синхронный запрос__ - ожидает получения ответа перед тем, как перейти к следующей задаче

Преимущества асинхронности:
- Повышение производительности за счет неблокирующего ввода-вывода
- Возможность обработать больше запросов без увеличения количества аппаратных ресурсов

IO bound и CPU bound

IO bound - задачи, время выполнения которых в основном определяется временем выполнения всех операций ввода/вывода.
CPU bound - скорость выполнения зависит преимущественно от мощности процессора.

__GIL__

GIL - Глобальная блокировка интерпретатора. Это мьютекс (mutex), который предотвращает выполнение нескольких потоков в одно и то же время. GIL гарантирует, что только один поток выполняет Python-код в любой момент времени. Это нужно, чтобы вся программа работала без сбоев: чтобы данные не перепутались и память правильно очищалась после того, как объекты перестают быть нужны.

Вот как GIL работает:
1. При запуске интерпретатора Python создается GIL.
2. Когда создается поток, он действительно "знает" о существовании GIL, но не столько "связывается" с ним, сколько учитывает его в своей работе. Поток не всегда активно взаимодействует с GIL — это происходит только в моменты, когда он выполняет инструкции, изменяющие состояние Python-объектов.
3. Перед выполнением поток проверяет, не занят ли GIL другим потоком. Если GIL свободен, поток блокирует его для себя и начинает выполнение кода. Это предотвращает одновременное изменение объектов другими потоками.
4. Если GIL занят, поток ожидает его освобождения. Python использует механизмы планирования потоков операционной системы, а также внутреннюю логику для определения, когда потоку следует попытаться захватить GIL снова.
5. Во время выполнения поток действительно может освобождать GIL, особенно при операциях ввода-вывода или при использовании определенных функций, которые явно освобождают GIL (например, time.sleep()). Это позволяет другим потокам получить доступ к выполнению, улучшая отзывчивость программы при операциях, не требующих постоянного доступа к Python-объектам.
6. После завершения своей работы поток освобождает GIL, позволяя другим потокам захватить его и продолжить выполнение.

Взаимодействие Asyncio и GIL
В простых асинхронных приложениях с использованием asyncio все задачи выполняются внутри одного потока. Но при операциях ввода-вывода GIL освобождается. Именно этот факт использует asyncio, что позволяет внутри одного потока в момент ожидания переключаться с одной задачи на другую и реализовывать конкурентное выполнение задач. При этом asyncio полностью подчиняется GIL, так что при кажущемся параллелизме, задачи в асинхронном приложении выполняются по очереди, передавая управление друг другу при ожидании ответа на запрос. 

Как обойти GIL?
Чтобы не сталкиваться с проблемой GIL, есть несколько трюков. Во-первых, можно попробовать многопроцессное программирование вместо того, чтобы работать с потоками. Это значит, что вы запускаете несколько процессов, и каждый из них работает на своём ядре процессора. Так вы сможете использовать все ресурсы компьютера на полную катушку.

Если вам нужно много считать, можно воспользоваться специальными библиотеками, например, NumPy или pandas. Они написаны с использованием языка C и могут обходить GIL, выполняя тяжёлые задачи в отдельных потоках или процессах, что ускоряет работу.

# Awaitable объекты

Awaitable объект - это объекты, ожидающие результатов

- Корутина - это функции, которые могут быть приостановлены и возобновлены.

Кооперативная многозадачность - задачи сами решают, когда им следует уступить контроль другим задачам. 
Вытесняющая многозадачность - операционная система принимает решения о том, когда задаче следует начать или прекратить выполнение.

- Задачи Task - используются для одновременного планирования сопрограмм
- Future - это специальный низкоуровневый ожидаемый объект, представляющий собой конечный результат асинхронной операции.


await - это ключевое слово, которое используется для переключения между awaitable объектами.

# Общие методы asyncio:

#### asyncio.run()

- `asyncio.run(coro, *, debug=None, loop_factory=None)` - функция создаёт цикл событий и запускает указанную корутину в нём. После завершения выполнения coro автоматически закрывает цикл событий.
  - `coro` - Coroutine, которую нужно запустить.
  - `debug` - Логический флаг, указывающий, следует ли запускать цикл событий в режиме отладки. Если None, значение берется из глобальной настройки отладки
  - `loop_factory` - представляет собой вызываемый объект (функцию или класс с методом __call__), который возвращает экземпляр цикла событий. Это позволяет пользователям предоставлять свою реализацию цикла событий или настроенный экземпляр цикла событий, который может иметь определенные настройки или расширения 

Особенности:
1. Создает и закрывает цикл событий
2. В рамках потока вызывается один раз
3. asyncio.run() нельзя вызвать из корутины. Это приведет к ошибке, так как функцию нельзя вызывать, когда другой цикл событий asyncio уже работает в том же потоке.
4. Может быть использован только с корутинами
5. не гарантирует порядок выполнения асинхронных операций внутри main(). Операции вернут результат по факту своего завершения
6. Возвращает результат работы передаваемой корутины
7. Ошибка, вызванная в одной из корутин, будет проброшена в вызывающий код



## asyncio.sleep()

- `asyncio.sleep(delay, result=None)` - приостанавливает исполнение текущей корутины, позволяя циклу событий (event loop) обрабатывать другие корутины или задачи.
  - `delay` - Количество секунд на которое нужно приостановить выполнение.
  - `result` - Значение, которое sleep() вернет после завершения задержки
 
Особенности:
1. Не блокирует поток выполнения программы, а только приостанавливает выполнение текущей корутины
2. Не точный метод -  выполнение корутины может быть приостановлено на более длительное время из-за переключения между задачами

# Методы для создания, запуска и ожидания задач: 

## asyncio.create_task()

- `asyncio.create_task(coro, *, name=None, context=None)` - функция оборачивает coro в объект Task, т.е. она будет запланирована для выполнения в цикле событий.
  - `coro` - Coroutine для оборачивания в Task
  - `name` -  Имя задачи. Может быть использовано для удобства отладки
  - `context` - Контекст выполнения, который будет связан с задачей. Это может быть использовано для передачи контекстной информации между задачами.
 
Особенности:
1. При создании задача только планируется к выполнению, но не начинает выполняться сразу. Выполняться задача начнет при первом переключении контекста (await)
2. Созданную задачу нужно ожидать с ключевым словом await
3. Задачи можно создать в любом количестве.
4. Порядок создания задач с помощью asyncio.create_task() может не совпадать с порядком завершения задач. 
5. должна использоваться в контексте асинхронной функции, которая затем запускается с помощью asyncio.run()
6. Ошибка, вызванная в одной из корутин, не будет выброшена немедленно.
7. Задачи, созданные с помощью asyncio.create_task(), могут быть отменены. 
8. Если одна из задач зависает, то все остальные задачи также могут зависнуть. 

## asyncio.ensure_future()
- `asyncio.ensure_future(coro_or_future, *, loop=None)` - это функция, которая используется для запуска корутины в асинхронном режиме.
  - `coro_or_future` - Объект, который должен быть обработан. Может быть корутиной, объектом Future или Task или любым другим объектом, поддерживающим асинхронное ожидание.
  - `loop` - Цикл событий, на котором должна быть запланирована задача.
 
Особенности:
1. Работает с любыми awaitable объектами
2. Является устаревшей, лучше использовать `create_task`


## asyncio.gather()
- `asyncio.gather(*aws, return_exceptions=False)` - одновременно запускает объекты awaitable, переданные в функцию как последовательность *aws.
  - `*aws` -Последовательность awaitable объектов, которые должны быть выполнены конкурентно
  - `return_exceptions` - Первое появившееся исключение, немедленно распространяется на ту задачу, в которой оно возникло в момент ожидания asyncio.gather(). При этом другие объекты в последовательности aws не будут отменены и продолжат выполнение. Если True то исключения обрабатываются так же, как успешные результаты и передаются в совокупный список результатов.
 
Особенности:
1. Конкурентное выполнение задач
2. возвращает список из результатов задач в том же порядке, в каком они переданы
3. Гибкое управление исключениями
4. Ограничение на использование ресурсов

## asyncio.wait_for()
- `asyncio.wait_for()` -  функция ожидает завершения aw(awaitable объект) и, если выполнение не завершено в течение timeout секунд, переданный awaitable объект отменяется и вызывается TimeoutError
  - `aw` - Awaitable объект, завершение которого ожидается
  - `timeout` - Максимальное количество секунд ожидания. Если timeout достигнут, будет вызван TimeoutError. Если None, то ожидание будет бесконечным.
 
Особенности:
1. asyncio.wait_for() должна использоваться с ключевым словом await
2. возвращает то же значение, что и завершенная задача
3. принимает любой awaitable объект
4.  не блокирует цикл событий
5. Если awaitable не возвращает результат до истечения таймаута - происходит ошибка
6. asyncio.shield() - защитить коррутину от отмены
7. 

```
import asyncio


async def my_coro():
    await asyncio.sleep(5)
    return 'Привет мир!'


async def main():
    await asyncio.wait_for(my_coro(), timeout=3)


asyncio.run(main())
```


## asyncio.wait()
- `asyncio.wait(aws, *, timeout=None, return_when=asyncio.ALL_COMPLETED)` - функция используется для конкурентного запуска  экземпляров Future и Task из итерируемого aws. Функция возвращает два множества Tasks/Futures: (done, pending). done: Множество задач, которые были выполнены или отменены. pending: Множество задач, которые ещё не были выполнены
  - `aws` - Итерируемый объект, содержащий awaitable объекты (Tasks/Futures). Этот итерируемый объект не должен быть пустым.
  - `timeout=None` - Максимальное количество секунд ожидания выполнения. 
  - `return_when=asyncio.ALL_COMPLETED` - Указывает, когда функция  asyncio.wait() должна вернуть управление. Может принимать одну из констант: FIRST_COMPLETED, FIRST_EXCEPTION, ALL_COMPLETED
    - `asyncio.FIRST_COMPLETED` - возвращает управление (т.е., "разблокирует" выполнение текущей корутины), как только любая из ожидаемых Task/Future будет выполнена или отменена.
    - `asyncio.FIRST_EXCEPTION` - возвращает управление, как только любая из ожидаемых задач завершится с исключением
    - `asyncio.ALL_COMPLETED` - значение по умолчанию, возвращает управление только после того, как все ожидаемые задачи будут выполнены или отменены.

 
Особенности:
1. Функция asyncio.wait() не вызывает исключение asyncio.TimeoutError при наступлении таймаута. Задачи, которые не были выполнены к этому моменту, просто возвращаются во множестве pending и продолжают свое выполнение в фоновом режиме.
2. В отличие от wait_for(), wait() не отменяет выполнение ожидаемых задач при наступлении таймаута.


```
import asyncio

async def task_slow():
    print("Starting slow task...")
    await asyncio.sleep(5)
    print("Slow task completed!")

async def task_fast():
    print("Starting fast task...")
    await asyncio.sleep(2)
    print("Fast task completed!")

async def main():
    # Создаем задачи
    slow = asyncio.create_task(task_slow())
    fast = asyncio.create_task(task_fast())
    
    # Ожидаем 3 секунды и смотрим, какие задачи завершились, а какие еще выполняются
    done, pending = await asyncio.wait([slow, fast], timeout=3)
    
    # Печатаем результаты
    for task in done:
        print(f"Task {task} is done!")
    
    for task in pending:
        print(f"Task {task} is still pending...")
    
    # Предположим, мы хотим продолжить выполнение оставшихся задач после короткой паузы
    print("Waiting a bit before resuming pending tasks...")
    await asyncio.sleep(2)
    
    # Продолжаем выполнение оставшихся задач
    for task in pending:
        await task

# Запускаем главную корутину
asyncio.run(main())
```

## asyncio.as_completed()
- `asyncio.as_completed(aws, *, timeout=None)` - возвращает результат каждой задачи по мере окончания, можно с этим результатом что то сделать и ожидать следующий

```
import asyncio
import random

async def task(num):
    await asyncio.sleep(delay := random.random())
    return f'Task {num} completed, {delay=:.3f}'

async def main():
    tasks = [asyncio.create_task(task(i)) for i in range(5)]
    
    for completed_task in asyncio.as_completed(tasks):
        # completed_task - объект корутины, создаваемый функцией as_completed(), возвращающий результат завершенной задачи.
        result = await completed_task
        print(result)

asyncio.run(main())
```

`asyncio.gather(*tasks)` - возвращает результаты (все разом) каждой задачи в том порядке, в котором задачи были поданы.

`asyncio.wait()` - как gather, но с возможностями до 1 результат и 1 ошибки, если ошибок нет, то возвращает все результаты разом

`asyncio.as_completed()` - возвращает результат каждой задачи по мере окончания, можно с этим результатом что то сделать и ожидать следующий

## asyncio.shield()
- `` -
  - `` -
  - `` -
 
Особенности:
1. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
# Методы для работы с циклом событий:

## asyncio.new_event_loop()

1. Создание нового цикла событий:
  - `loop = asyncio.new_event_loop()`
2. Запуск созданного цикла событий (в однопоточном приложении этот шаг необязателен)
  - `asyncio.set_event_loop(loop)` - Позволяет установить экземпляр цикла событий loop в качестве текущего цикла событий для текущего потока, а в противном случае asyncio использует цикл событий, созданный по умолчанию
3. Запуск корутины из созданного цикла событий:
  - `loop.run_until_complete(coro())`
4. По окончании работы с циклом событий нужно закрыть его вручную*:
  - `loop.close()`

Примечания:
1. В большинстве случаев рекомендуется использовать высокоуровневый `asyncio.run()`
2. Можно создать несколько разных циклов событий в рамках одного приложения
3. В одном процессе/потоке может быть только один цикл событий в любой момент времени
4. Цикл событий надо закрывать вручную
5. `loop.is_running()` - возвращает True, если цикл событий активен.
6. `loop.is_closed()` - возвращает True, если цикл событий закрыт

## asyncio.set_event_loop(loop)

`asyncio.set_event_loop(loop)` -  Позволяет установить экземпляр цикла событий loop в качестве текущего цикла событий для текущего потока, а в противном случае asyncio использует цикл событий, созданный по умолчанию

Примечания:
1. Нельзя запустить два цикла событий в одном потоке одновременно.
2. Использование нескольких циклов событий в разных потоках усложняет код.
3. Использование нескольких циклов событий в разных потоках увеличивает нагрузку на управление ресурсами.
4. Необходимо тщательно рассмотреть, когда стоит использовать один или несколько циклов событий, в зависимости от специфики задачи.
5. Критически важно применять разные циклы событий для различных потоков или процессов.

## loop.run_until_complete(future)
## asyncio.get_event_loop()

`asyncio.get_event_loop()` - возвращает текущий цикл событий для текущего контекста выполнения. Если текущий цикл событий еще не установлен, будет пытаться установить новый цикл событий и вернуть его
## asyncio.get_running_loop()

`asyncio.get_running_loop()` - возвращает запущенный цикл событий в текущем потоке ОС. Если цикл событий не запущен, get_running_loop() вызовет ошибку RuntimeError

# Методы для работы асинхронных приложений в нескольких потоках:

## asyncio.run_coroutine_threadsafe()
## asyncio.to_thread()

- `asyncio.to_thread(func, /, *args, **kwargs)` - метод возвращает корутину, которую можно ожидать, чтобы получить конечный результат работы func. Асинхронный запуск синхронных блокирующих функций в отдельном потоке. В качестве func может быть передана любая синхронная функция
  - `` -
  - `` -

Что происходит, когда блокирующая функция выполняется с помощью asyncio.to_thread()?
Она выполняется в отдельном потоке, позволяя основному циклу событий продолжать работу.
 


## Задачи
Задача/Task — это объект, который планирует, управляет и независимо от других задач запускает корутину в цикле событий.  Задача оборачивает корутину, планирует ее выполнение и предоставляет способы взаимодействия с ней. Задачи используются для одновременного планирования и запуска любого количества корутин. Когда корутина "обёрнута" в задачу функцией asyncio.create_task(coro), корутина (coro) автоматически запускается в ближайшее время. 
Задачи предоставляют *дескриптор независимо от запланированных и запущенных корутин в цикле событий и позволяют запрашивать, отменять задачу, а также получать результаты и исключения.

У задачи есть три состояния:
-pending
-finished 
-cancelled

методы проверки состояния: 
- `done()` - возвращает True, если задача завершена, то есть находится в состоянии finished или cancelled.
- `cancelled()` - возвращает True, если задача отменена, то есть находится в состоянии cancelled

Исключение можно будет получить с помощью метода exception().

Жизненный цикл задачи
![image](https://github.com/user-attachments/assets/50a5e02c-654c-4a29-83fd-464666352ba3)


Создание экземпляра класса задачи:
1. Для создания экземпляра класса задачи используется метод asyncio.create_task()
2. Функция create_task() возвращает объект Task. Этот объект становится управляемой задачей.
3. Cохранение ссылки на задачу в переменной даёт возможность взаимодействовать с задачей после её создания

Методы класса Task:
- Статус задачи и обращение к результатам задачи:
  - task.done() — возвращает True, если задача выполнена или отменена.
   Задача считается завершенной, если:
      1. корутина, связанная с задачей, закончила выполнение и вернула результат,
      2. если задача была отменена,
      3. корутина, связанная с задачей, выбросила исключение.
  - task.result() — возвращает результат выполнения задачи, если она выполнена. Если результат задачи еще не доступен, то метод вызывает исключение InvalidStateError
  - task.exception() — возвращает исключение, которое было выброшено при выполнении задачи.
- Получение и изменение имени задачи:
  - task.get_name() — возвращает имя задачи
  - task.set_name(name) — устанавливает имя задачи.
- Отмена задач и работа с отмененными задачами:
  - task.cancel() — отменяет выполнение задачи.
  - task.cancelled() — возвращает True, если задача была отменена до ее выполнения.
  - task.cancelling() — возвращает количество ожидающих отмены запросов к этой задаче.
  - task.uncancel() — отмена отмены задачи.
- Получение связанных с задачей объектов:
  - task.get_coro() — возвращает корутину, связанную с задачей.
  - task.get_loop() — возвращает цикл событий, связанный с задачей.
  - task.get_stack() — возвращает стек выполнения задачи.
  - task.print_stack(file=None) — выводит стек выполнения задачи в файл или на экран.
- Работа с функциями обратного вызова
  - task.add_done_callback(fn) — добавляет функцию обратного вызова, которая будет вызвана после завершения выполнения задачи.
  - task.remove_done_callback(fn) — удаляет функцию обратного вызова, связанную с задачей.
- Функции модуля asyncio для работы с задачами:
  - asyncio.current_task() — Возвращает текущий запущенный экземпляр Task или None, если ни одна задача не запущена.
  - asyncio.all_tasks() — возвращает множество (set) объектов Task, которые еще не завершены и выполняются циклом событий. 
