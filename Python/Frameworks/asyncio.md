
__Асинхронное программирование__ - Способ программирования, при котором можно выполнять множество задач конкурентно, не дожидаясь завершения предыдущей.

__Синхронный запрос__ - ожидает получения ответа перед тем, как перейти к следующей задаче

Преимущества асинхронности:
- Повышение производительности за счет неблокирующего ввода-вывода
- Возможность обработать больше запросов без увеличения количества аппаратных ресурсов

IO bound и CPU bound

IO bound - задачи, время выполнения которых в основном определяется временем выполнения всех операций ввода/вывода.
CPU bound - скорость выполнения зависит преимущественно от мощности процессора.

__GIL__

GIL - Глобальная блокировка интерпретатора. Это мьютекс (mutex), который предотвращает выполнение нескольких потоков в одно и то же время. GIL гарантирует, что только один поток выполняет Python-код в любой момент времени. Это нужно, чтобы вся программа работала без сбоев: чтобы данные не перепутались и память правильно очищалась после того, как объекты перестают быть нужны.

Вот как GIL работает:
1. При запуске интерпретатора Python создается GIL.
2. Когда создается поток, он действительно "знает" о существовании GIL, но не столько "связывается" с ним, сколько учитывает его в своей работе. Поток не всегда активно взаимодействует с GIL — это происходит только в моменты, когда он выполняет инструкции, изменяющие состояние Python-объектов.
3. Перед выполнением поток проверяет, не занят ли GIL другим потоком. Если GIL свободен, поток блокирует его для себя и начинает выполнение кода. Это предотвращает одновременное изменение объектов другими потоками.
4. Если GIL занят, поток ожидает его освобождения. Python использует механизмы планирования потоков операционной системы, а также внутреннюю логику для определения, когда потоку следует попытаться захватить GIL снова.
5. Во время выполнения поток действительно может освобождать GIL, особенно при операциях ввода-вывода или при использовании определенных функций, которые явно освобождают GIL (например, time.sleep()). Это позволяет другим потокам получить доступ к выполнению, улучшая отзывчивость программы при операциях, не требующих постоянного доступа к Python-объектам.
6. После завершения своей работы поток освобождает GIL, позволяя другим потокам захватить его и продолжить выполнение.

Взаимодействие Asyncio и GIL
В простых асинхронных приложениях с использованием asyncio все задачи выполняются внутри одного потока. Но при операциях ввода-вывода GIL освобождается. Именно этот факт использует asyncio, что позволяет внутри одного потока в момент ожидания переключаться с одной задачи на другую и реализовывать конкурентное выполнение задач. При этом asyncio полностью подчиняется GIL, так что при кажущемся параллелизме, задачи в асинхронном приложении выполняются по очереди, передавая управление друг другу при ожидании ответа на запрос. 

Как обойти GIL?
Чтобы не сталкиваться с проблемой GIL, есть несколько трюков. Во-первых, можно попробовать многопроцессное программирование вместо того, чтобы работать с потоками. Это значит, что вы запускаете несколько процессов, и каждый из них работает на своём ядре процессора. Так вы сможете использовать все ресурсы компьютера на полную катушку.

Если вам нужно много считать, можно воспользоваться специальными библиотеками, например, NumPy или pandas. Они написаны с использованием языка C и могут обходить GIL, выполняя тяжёлые задачи в отдельных потоках или процессах, что ускоряет работу.

# Awaitable объекты

Awaitable объект - это объекты, ожидающие результатов

- Корутина - это функции, которые могут быть приостановлены и возобновлены.

Кооперативная многозадачность - задачи сами решают, когда им следует уступить контроль другим задачам. 
Вытесняющая многозадачность - операционная система принимает решения о том, когда задаче следует начать или прекратить выполнение.

- Задачи Task - используются для одновременного планирования сопрограмм
- Future - это специальный низкоуровневый ожидаемый объект, представляющий собой конечный результат асинхронной операции.


await - это ключевое слово, которое используется для переключения между awaitable объектами.

# Общие методы asyncio:

## asyncio.run()

`asyncio.run(coro, *, debug=None, loop_factory=None)` - функция создаёт цикл событий и запускает указанную корутину в нём. После завершения выполнения coro автоматически закрывает цикл событий.
- coro
- debug
- loop_factory


## asyncio.sleep()

# Методы для создания, запуска и ожидания задач: 

## asyncio.create_task()

## asyncio.ensure_future()
## asyncio.gather()
## asyncio.wait_for()
## asyncio.wait()
## asyncio.shield()

# Методы для работы с циклом событий:

## asyncio.new_event_loop()
## asyncio.set_event_loop(loop)
## loop.run_until_complete(future)
## asyncio.get_event_loop()
## asyncio.get_running_loop()

# Методы для работы асинхронных приложений в нескольких потоках:

## asyncio.run_coroutine_threadsafe()
## asyncio.to_thread()

