

# Теория

Процесс — это абстракция, реализованная на уровне операционной системы. Процесс рассматривается ОС, как заявка на все виды ресурсов (память, файлы и пр.), кроме одного — процессорного времени.  это просто контейнер, в котором находятся ресурсы программы:
- адресное пространство
- потоки
- открытые файлы
- дочерние процессы
- и тд


Поток — это абстракция, реализованная на уровне операционной системы. Поток был придуман для контроля выполнения кода программы. Поток — это заявка на процессорное время.
Поток — это просто контейнер, в котором находятся:
- Счётчик команд
- Регистры
- Стек

Поток легче, чем процесс, и создание потока стоит дешевле. Потоки используют адресное пространство процесса, которому они принадлежат, поэтому потоки внутри одного процесса могут обмениваться данными и взаимодействовать с другими потоками.

Почему нужна поддержка множества потоков внутри одного процесса?

В случае, когда одна программа выполняет множество задач, поддержка множества потоков внутри одного процесса позволяет:
- Разделить ответственность за разные задачи между разными потоками
- Повысить быстродействие

Мьютекс — это базовый механизм для синхронизации потоков, который позволяет только одному потоку в данный момент времени получить доступ к критической секции. (Локи, семафор, Ивенты и п.р.)

Критические секции (Critical Sections). Двойное понятие. Так называют и защищаемую часть кода, участок, выполнение которого нужно ограничить. И это конкретные механизмы блокировки Windows, которые предоставляются операционной системой и позволяют защитить критические участки кода от параллельного выполнения разными потоками.

GIL

Если бы его не было:
![image](https://github.com/user-attachments/assets/7355046f-8841-4f47-ae5c-08e9e5864e74)

Работа потоков с GIL
![image](https://github.com/user-attachments/assets/cf94c269-2588-4b39-ac8f-1c0791e73d64)



# threading

- `threading.Thread(target=None, name=None, args=(), kwargs={}, daemon=None)` - создания экземпляра объекта потока. (Только ключевые аргументы)
  - `target` - целевая функция (вызываемый объект), которую будет выполнять этот поток
  - `name` -  имя потока
  - `args`, `kwargs` - позиционные и именованные аргументы для нашей целевой функции, причем args указывается через кортеж или список; 
  - `daemon` - флаг, указывающий поведение потока. позволяет создавать демонический поток (выполнение потока как службы в фоне, который можно не дожидаться)

 1. Для запуска вызываем метод .start()
 2. `MainThread` - главный поток
 3. Метод `join()` блокирует работу только того потока, который его вызвал. Остальные потоки продолжают свою работу. Таким образом join-ы, позволяют дождаться завершения дополнительных потоков и, например, позволяют организовывать обработку общего результата от многих запущенных потоков. Блокируем работу потока, который вызвал join до завершения работы потока, которого ждем и все тут.


- `threading.active_count()` - возвращает количество активных потоков (целое число);
- `threading.current_thread()` - возвращает текущий поток, соответствующий потоку выполнения вызывающего объекта.
- `threading.main_thread()` - возвращает главный поток. По умолчанию основным потоком является поток, из которого был запущен интерпретатор Python.
- `Thread.name` - возвращает (и задает) имя потока;
- `Thread.is_alive()` - проверяет поток на активность, возвращает True или False.
- `threading.get_ident()` - возвращает ненулевое целое число, которое однозначно идентифицирует текущий поток среди других потоков, существующих одновременно. Может использоваться при индексации данных потока, может служить ключом в коллекции данных потока. Идентификаторы потока могут быть повторно назначены при выходе из потока и создании другого потока.
- `threading.get_native_id()` - тоже идентификатор, но этот id назначается операционной системой и он может быть использован для идентификации конкретного потока в пределах системы. Поток операционной системы часто называют нативным (native), отсюда и название функции идентификатора. Этот системный идентификатор также может называться интегральным идентификатором.
- `threading.enumerate()` - возвращает список всех активных (живых) потоков.
- `threading.stack_size([size])` - возвращает размер стека, используемый при создании новых потоков. И изменяет размер стека. Необязательный аргумент size указывает размер стека, который будет использоваться для создаваемых впоследствии потоков, и должен быть равен 0 (по умолчанию) при использовании настроек платформы или положительному целочисленному значению не менее 32768. Если size не указан, то используется 0. Если изменение размера стека потока не поддерживается, возникает ошибка RuntimeError. Если указанный размер стека недействителен, возникает ошибка ValueError и размер стека не изменяется.

`threading.excepthook(args, /)` - обрабатывает не перехваченные исключения, вызванные в методе run() потока. Обратите внимание, в функцию обязательно передается один аргумент args. Всегда, даже если Вы не намерены его использовать. Нельзя вызывать функцию threading.excepthook() без аргумента. Это приведет к ошибке:
- TypeError: custom_hook() takes 0 positional arguments but 1 was given.
- Аргумент args имеет следующие атрибуты:
  - `exc_type` - тип исключения;
  - `exc_value` - значение исключения (сообщение исключения), может быть None;
  - `exc_traceback` - трассировка исключения (трассировка стека исключения), может быть None. Представляет собой список фреймов выполнения программы, начиная с точки возникновения исключения и возвращающийся до корневого фрейма (главной программы). Каждый фрейм содержит информацию о вызванной функции, файле и строке кода, где произошло исключение;
  - `exc_thread` - поток, который вызвал исключение, может быть None.

deamon

False
![image](https://github.com/user-attachments/assets/fab3f125-0900-4b80-9c79-f5bf220cce15)


True
![image](https://github.com/user-attachments/assets/f994aa99-c718-47b0-a429-197d9f95d65a)


# Обработка исключений

```
import threading

def error_except(args):
    exc_type, exc_value, exc_traceback, exc_thread = args
    print(f'{exc_thread.name}, {exc_type.__name__}, {exc_value}')


threading.excepthook = error_except
```


# Переопределение потоков

```
import threading


class PrintThread(threading.Thread):  # наследуем оригинальный класс Thread

    def __init__(self, text): 
        super().__init__()
        self.text = text
        # выведите на печать количество активных потоков

    def run(self):  # переопределение метода run
        # выведите на печать количество активных потоков
        print(self.text)


print_thread = PrintThread("Очень простой но бесполезный пример работы отдельного потока")
print_thread.start()
```

Получить результат работы

```
y_thread_1 = MyNewThread(new_arg)
my_thread_1.start()
my_thread_1.join()
res = my_thread_1.result
```

# Очереди

- `queue.Queue(maxsize=0)` - создает очередь FIFO, где maxsize - это целое число, которое устанавливает верхний предел количества элементов, которые могут быть помещены в очередь. Вставка нового элемента будет заблокирована после достижения этого размера. Если maxsize меньше или равен нулю - размер очереди не ограничен.
```
import queue

my_queue = queue.Queue(maxsize=10) # указали ограничение размера в 10 элементов
```

- `queue.LifoQueue(maxsize=0)` создает очередь LIFO

```
import queue

my_queue = queue.LifoQueue(10)
```

- `queue.PriorityQueue(maxsize=0)` создает очередь с приоритетом.  В такой очереди первыми извлекаются объекты с наименьшим значением. Для возможности выбора минимального, объекты в очереди должны иметь возможность сравнения. При этом есть два варианта:
  - объекты, добавляемые в приоритетную очередь обязательно должны иметь метод сравнения ("магический" метод __lt__() для оператора меньше <). Об этом обязательно нужно помнить, если в очереди планируется использовать объекты собственных типов;
  - использовать вспомогательный элемент, например кортеж. В очередь добавляется не просто объект, а кортеж с двумя элементами: (уникальный приоритет, объект). Тогда выбор минимального объекта в очереди для извлечения будет происходить согласно уникальному приоритету. В качестве уникального приоритета проще всего использовать числа.

 ```
import queue

my_queue = queue.PriorityQueue()  # без ограничения по размеру
```

- `SimpleQueue` - В отличие от Queue она:
  - Не предоставляет возможности для ограничения размера очереди и не блокирует потоки при размещении (добавлении) элементов в очереди;
  - не предусматривает работу с задачами;

```
import queue

my_queue = queue.SimpleQueue()
```

Методы работы с очередями:
- `Queue.put(item, block=True, timeout=None)` - размещает (добавляет) элемент item в очереди. Похож на метод append для списка.
  - с аргументами по умолчанию добавление элемента в очередь блокируется до тех пор, пока не освободится свободный слот;
  - если block=True, а таймаут timeout задан положительным числом, то добавление элемента в очередь блокируется на максимальное время ожидания timeout. Если в течение этого времени не было свободного места в очереди, то возбуждается исключение queue.Full (см. ниже). Если в очереди было место для добавления элемента - никакого блокирования не происходит.;
  - если  block=False, то таймаут игнорируется. Если свободный слот не доступен, то попытка добавления элемента возбуждает исключение queue.Full.
- `Queue.put_nowait(item)` - размещает элемент в очереди без блокировки и ожиданий.
- `queue.Full` - исключение, которое возникает, когда неблокирующая функция put() или put_nowait() вызывается для заполненной очереди (очереди с размером равном maxsize).
- `Queue.get(block=True, timeout=None)` - возвращает (получает) элемент item из очереди и сразу же удаляет этот элемент из очереди, т.е. извлекает элемент. Похож на метод pop для списка.
  - с аргументами по умолчанию при попытке извлечения элемента происходит блокировка, пока элемент не станет доступен в очереди (т.е. пока не будет что извлекать);
  - если таймаут timeout задан положительным числом, то извлечение элемента из очереди блокируется на максимальное время ожидания timeout. Если в течение этого времени ни один элемент не был доступен для извлечения, то возбуждается исключение queue.Empty. Если в очереди был элемент для извлечения - никакого блокирования не происходи.
  - если  block=False, то timeout игнорируется. Если очередь пустая, то попытка извлечения элемента возбуждает исключение queue.Empty.
- `Queue.get_nowait()` - эквивалентен вызову метода Queue.get(False), т.е. вызову с параметрами block=False, timeout=None. При работе с методами без ожидания и блокировок нужно быть осторожным, большой риск получить конфликты и ошибки при работе с двумя и более потоками - участниками.
- `queue.Empty` - возникает, когда неблокирующая функция get() или get_nowait() вызывается для пустой очереди.
- `Queue.qsize()` - возвращает примерный размер очереди (целое число). Примерный, т.к. размер после получения может сразу же изменится в результате работы (обращения к очереди) другого потока. Нельзя использовать для определения "крайних" состояний очередей: полная очередь, пустая очередь. Для этого есть специальные методы определения;
  - `Queue.empty()` - возвращает True, если очередь пустая. Иначе - False;
  - `Queue.full()` - по аналогии, возвращает True, если очередь полная. Иначе - False.


### Локальные переменные

```
import threading

stor = threading.local() # Создаем объект локального хранилища
stor.a = 100  # Создаем атрибут, доступный только Main потоку и передаем ему значение
```

Локальные переменные для каждого потока свои. Внутри реализован словарь где ключ - имя потока, значение - его локальные переменные

Можно самому написать class унаследовавшись от threading.local()

```
from threading import Thread, local

# где-то определен stor_local = local()


def make_msg(stor_local: local):
    authentication = hasattr(stor_local, "authentication")
    fileno = None
    date_and_time = None
    if hasattr(stor_local, "fileno"):
        fileno = stor_local.fileno
    if hasattr(stor_local, "dt"):
        date_and_time = stor_local.dt
    return f"{authentication=}, {fileno=}, {date_and_time=}"
```

### Синхронизация потоков

- __threading.Lock__ - дает эксклюзивный доступ к разделяемому ресурсу только одному потоку. "Запирает" ресурс.
- __threading.RLock__ - тоже что и Lock, но с повторным доступом.
- __threading.Event__ - может заблокировать потоки в wait(), пока событие не получит сигнал с помощью set().
- __threading.Сondition__ - объединяет в себе Lock и Event: позволяет организовать блокировку (Lock) с использованием условия по событию (Event).
- __threading.Semaphore__ - позволяет ограничивать доступ к разделяемому ресурсу по количеству захвативших его потоков.
- __threading.BoundedSemaphore__ - ограниченный Semaphore с защитой от излишних вызовов .release().
- __threading.Barrier__ - используется для ожидания завершения N - потоков. Барьер преодолевается, когда все N потоков завершились.

![image](https://github.com/user-attachments/assets/4e75ea96-348b-4c63-b63b-10ae82de9ca9)


#### Lock

![image](https://github.com/user-attachments/assets/98346796-237f-4672-83f5-4836ebca3eff)


```
import threading

x = 0

lock = threading.Lock()  # Создаем объект блокировки

def increment():
    global x
    lock.acquire()  # Захватываем (блокируем)
    x += 1  # защищаемая критическая секция
    lock.release()  # Снимаем (отпускаем) блокировку
```

- `acquire(blocking=True, timeout=-1)` 
  - `blocking=False`, в этом случае вызов метода при захваченном Lock - объекте не будет приводить к блокировке, метод просто вернет False. Если вызов метода произойдет при свободном Lock - объекте, метод переведет Lock - объект в заблокированное состояние и вернет True.
  - `timeout` задает время (в секундах: int, float) ожидания (блокирования) метода acquire захватить уже занятый Lock-объект.
- `release()` вызывается без параметров. Ничего не возвращает, просто освобождает (разблокирует) Lock - объект. Может быть вызван из любого потока, а не только из потока, который получил блокировку (захватил Lock - объект).
-  locked() также вызывается без параметров. Используется для проверки состояния Lock - объекта. Возвращает True, если объект захвачен, False - если нет.
__Но лучше использовать контекстный менеджер__



#### RLock

RLock
- reentrant lock или повторный lock, обладает тремя отличительными особенностями (работает как рекурсивный, увеличивает счетчик блокировок):
  1. Объект RLock может освободить только тот поток, который его захватил.
  2. Поток может повторно захватить RLock. При этом повторный захват потоком уже захваченного RLock-объекта не блокирует дальнейшее выполнение потока.
  3. Отсутствует метод locked().

- Метод acquire(blocking=True, timeout=-1) может быть вызван с параметрами blocking и timeout c другими значениями, чем значения по умолчанию:
  - blocking=False, в этом случае вызов метода при захваченном RLock - объекте не будет приводить к блокировке, не будет увеличивать счетчик, метод просто вернет False. Если вызов метода произойдет при свободном RLock - объекте, метод переведет RLock - объект в заблокированное состояние и вернет True.
  - timeout задает время (в секундах: int, float) ожидания (блокирования) метода acquire захватить уже занятый RLock-объект.

- Метод `release()` вызывается без параметров. Ничего не возвращает. Уменьшает счетчик уровня рекурсии на единицу при каждом вызове, если этот вызов выполняется потоком, который захватил Rlock объект.

#### Event

threading.Event - класс реализует объект события, простой механизм взаимодействия потоков. Объект класса Event управляет внутренним флагом, который сбрасывается в False с помощью метода clear() и устанавливается в True методом set(). Метод wait() блокирует дальнейшее выполнение потока, если флаг сброшен. При создании объекта флаг установлен в значении False (не установлен, unset).

1. Основной метод wait(timeout=None) блокируется, пока флаг не станет True. Если при вызове метода флаг уже True, то метод сразу возвращает True. Если выставлен таймаут отличный от значения по умолчанию и значение флага не True, метод будет блокироваться по таймауту, ожидая установки флага. После окончания таймаута, не дождавшись установки флага, метод вернет False. Таймаут устанавливается в секундах (int, float).
2. Метод set() устанавливает флаг в значение True. Ничего не возвращает. Открывает двери торгового центра. Может быть вызван без ошибок сразу несколько раз подряд.
3. Метод clear(), наоборот, сбрасывает флаг в значение False. Ничего не возвращает. Закрывает двери торгового центра. Может быть вызван без ошибок раньше метода set() и может быть вызван сразу несколько раз подряд.
4. Метод is_set() возвращает True тогда и только тогда, когда внутренний флаг имеет значение True (и False - когда флаг в значении False).

#### Сondition

threading.Condition(lock=None) - создает объект синхронизации с условием. В качестве объекта блокировки может быть использованы только объекты Lock или Rlock. По умолчанию используется объект Rlock. Если хотим использовать Lock, указываем lock=threading.Lock()

Основные методы Condition:
- acquire() Захватывает блокировку (lock) для синхронизации потока.
- release() Освобождает блокировку (lock) после работы с критической секцией.
- wait(timeout=None) Блокирует поток, ожидая изменения состояния. Опциональный timeout задает время ожидания.
- notify() Уведомляет один поток о том, что состояние изменилось.
- notify_all() Уведомляет все потоки, ожидающие изменения состояния.
- wait_for(predicate, timeout=None) - predicate: Функция-условие, возвращающая True или False. Поток будет ждать, пока это условие не станет True.
timeout: (опционально) Максимальное время ожидания в секундах. Если истечет время, возвращается False.

#### Semaphore \  BoundedSemaphore

![image](https://github.com/user-attachments/assets/d9517746-a24f-4e12-bad3-5fcddbf6182e)

Семафор - семафор способен разрешать одновременное выполнение нескольким потокам.

Семафор управляет внутренним счетчиком, который уменьшается при каждом вызове acquire и увеличивается при каждом вызове release. 

Семафор как лифт, который работает, только если не перегружен. Подняться одному - без проблем. Втроем - тоже. Но пятерых не увезет.

threading.Semaphore(value=1) - возвращает объект семафора. Семафор управляет атомарным счетчиком, представляющим количество вызовов release() минус количество вызовов acquire() плюс начальное значение value. Необязательный аргумент задает начальное значение для внутреннего счетчика, по умолчанию оно равно 1. Если указать значение меньше 0, возбуждается исключение ValueError.

- Методы
  - Указывая значение value при создании объектов семафора мы определяем ограничение на внутренний счетчик. Это ограничение будет соответствовать количеству одновременных потоков, которые могут захватывать (лучше сказать "поднимать") семафор.
  -  Метод acquire(blocking=True, timeout=None) захватывает (поднимает) семафор. Может быть вызван с параметрами blocking и timeout c другими значениями, чем значения по умолчанию.
    - Если вызывается без изменения значений по умолчанию, то:
      - если внутренний счетчик больше 0: уменьшит его на единицу и немедленно вернет True;
      - если внутренний счетчик равен нулю: блокируется до тех пор, пока внутренний счетчик не станет больше 0 (вызовом release), затем уменьшит его на единицу и тогда вернет True.
      - Если вызывается с blocking=False, то метод не блокируется, а немедленно возвращает False или True. Возвращает False, если вызов метода без аргументов не поднял бы семафор (или True, если бы поднял).
timeout задает время (в секундах: int, float) ожидания (блокирования) метода acquire возможности поднять семафор. Если за этот интервал времени поднять семафор не получится - метод вернет False. В случае успеха - True. Имеет смысл указывать только при blocking=True. Иначе - возникает ошибка ValueError: can't specify timeout for non-blocking acquire
    - Метод release(n=1) освобождает (опускает) семафор. При вызове с значением по умолчанию увеличивает внутренний счетчик на единицу. Или на n, если явно указать этот параметр. Таким образом можно пробуждать сразу несколько потоков, ожидающих возможности поднятия семафора.
    - Семафоры поддерживают протокол управления контекстом.

 ![image](https://github.com/user-attachments/assets/1803a711-326f-450e-bf62-c8754c3a48a8)

  
threading.BoundedSemaphore(value=1) - возвращает объект ограниченного (или защищенного) семафора. Ограниченный семафор проверяет, не превышает ли его текущее значение счетчика установленному значению при его создании. Если это происходит, то возникает ValueError. В большинстве ситуаций семафоры используются для защиты ресурсов с ограниченной пропускной способностью. Если семафор освобождают (методом release) слишком много раз, это - признак ошибки.


#### Barrier

Барьер - примитив синхронизации, применяющийся в тех случаях, когда необходимо организовать поэтапную работу нескольких потоков - участников, где каждый следующий этап подразумевает ожидание завершения предыдущего этапа работы всех участников. Если логика задачи требует соблюдения этапности работ: никто не начинает следующий этап, пока все не закончат предыдущий - то нужно применять барьер.

![image](https://github.com/user-attachments/assets/1251ac3c-d053-40e2-9b07-ae197b97d794)

1. Потоки выполняются до тех пор, пока не встретят барьер. Каждый поток, достигая барьера, блокируется до тех пор, пока другие участники тоже не достигнут этого барьера.
2. Когда все участники достигают барьера,
3. блокировка снимается, барьер преодолен. Потоки освобождаются одновременно и продолжают свое выполнение.
4. А барьер тут же "закрывается", заново начиная блокировать потоки.

- wait(timeout=None) — Ожидание на барьере.
- reset() — Сбрасывает барьер. возвращает барьер в дефолтное состояние 
- abort() — Прерывает барьер. переводит барьер в нерабочее (сломанное) состояние
- Статус объекта барьера можно проверить с помощью атрибутов
  - parties — Общее количество потоков, которое должен ожидать барьер.
  - n_waiting — Число потоков, которые уже ждут на барьере.
  - broken — Показывает, сломан ли барьер.

`threading.Barrier(parties, action=None, timeout=None)` - возвращает объект барьера для использования parties (int) числом потоков. action - объект (должен быть вызываемый), который будет вызван одним из потоков в момент, когда потоки будут освобождены (потоки преодолеют барьер). timeout задает время таймаута по умолчанию (в секундах: int, float) для метода wait().

Метод `wait(timeout=None)` - основной рабочий метод барьера. Блокирует работу потоков до тех пор, пока все потоки (не абсолютно все, а то количество потоков, которое указанно в аргументе parties) не вызовут этот метод.


### Пулл потоков

- `concurrent.futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix='', initializer=None, initargs=())`, где:
  - max_workers, int - максимальное количество потоков в пуле. Если max_workers не задан или равен None, то он устанавливает значение по умолчанию вычисленное как min(32, os.cpu_count() + 4). Это значение по умолчанию сохраняет как минимум 5 рабочих потоков для задач, связанных с операциями ввода/вывода и избегает неявного использования очень больших ресурсов на многоядерных машинах.
  - thread_name_prefix - префикс имени потока, который будет использоваться для именования всех потоков, создаваемых пулом. Это может быть полезно для отладки, чтобы было проще понять, какой поток относится к какой задаче.
  - initializer - вызываемый объект, который будет вызываться в начале каждого рабочего потока, перед выполнением любой задачи. Это может быть полезно, например, для инициализации состояния, которое используется во всех задачах. Если initializer генерирует исключение, все текущие ожидающие задачи вызовут BrokenThreadPool, а также любая попытка отправки задач в пул потоков завершится этим исключением.
  - initargs - кортеж аргументов, которые будут переданы в initializer при его вызове.
 
- map(fn, *iterables, timeout=None, chunksize=1) - функция, которая применяется для обработки элементов из нескольких последовательностей (iterables) параллельно с использованием функции fn.
  - fn: Функция, которая применяется к элементам из каждой из последовательностей.
  - iterables: Последовательности (списки, кортежи, строки и т.д.), для которых будет применяться функция.
  - timeout: (Опционально) Ограничение времени выполнения каждой функции.
  - chunksize: (Опционально) Количество элементов, обрабатываемых одновременно.
- submit(fn, /, *args, **kwargs) -  метод, который создаёт Future объект для асинхронного выполнения функции fn с заданными аргументами и параметрами.
  - fn: Функция, которая будет асинхронно выполняться.
  - args: Позиционные аргументы для функции.
  - kwargs: Ключевые аргументы для функции.

- future
  - cancel() - пытается отменить вызов задачи. Если вызов был успешно отменен, метод cancel() возвращает True. Если вызов был уже отменен до этого или задача уже завершилась (или она выполняется), метод cancel() возвращает False.
  - cancelled() - возвращает True, если вызов был успешно отменен.
  - running() - возвращает значение True, если вызов в данный момент выполняется и не может быть отменен
  - done() - возвращает значение True, если вызов был успешно отменен или завершен

Экземпляру Future можно назначить коллбэк, используя метод
add_done_callback(fn) где fn - вызываемый объект (функция обратного вызова). fn будет автоматически вызван как только Future будет завершена или отменена

Callback (англ. call — вызов, англ. back — обратный) или фу́нкция обра́тного вы́зова в программировании — передача исполняемого кода в качестве одного из параметров другому коду. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове. Этот код может быть определён в других контекстах программного кода и быть недоступным для прямого вызова из этой функции. Некоторые алгоритмические задачи в качестве своих входных данных имеют не только числа или объекты, но и действия (алгоритмы), которые естественным образом задаются как обратные вызовы. /wiki/

В общем и целом программирование на коллбэках  - это подход, который включает в себя некоторое связывание объекта будущего вызова (функции вызова) с каким-то условием этого вызова. Если что-то произойдет, то вызови эту функцию. Если другое произойдет - вызови другую функцию. Коллбэки широко распространены в концепции асинхронного выполнения: если что-то будет готово - вызови функцию работы с готовым результатом.
