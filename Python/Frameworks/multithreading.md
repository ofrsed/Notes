

# Теория

Процесс — это абстракция, реализованная на уровне операционной системы. Процесс рассматривается ОС, как заявка на все виды ресурсов (память, файлы и пр.), кроме одного — процессорного времени.  это просто контейнер, в котором находятся ресурсы программы:
- адресное пространство
- потоки
- открытые файлы
- дочерние процессы
- и тд


Поток — это абстракция, реализованная на уровне операционной системы. Поток был придуман для контроля выполнения кода программы. Поток — это заявка на процессорное время.
Поток — это просто контейнер, в котором находятся:
- Счётчик команд
- Регистры
- Стек

Поток легче, чем процесс, и создание потока стоит дешевле. Потоки используют адресное пространство процесса, которому они принадлежат, поэтому потоки внутри одного процесса могут обмениваться данными и взаимодействовать с другими потоками.

Почему нужна поддержка множества потоков внутри одного процесса?

В случае, когда одна программа выполняет множество задач, поддержка множества потоков внутри одного процесса позволяет:
- Разделить ответственность за разные задачи между разными потоками
- Повысить быстродействие


# threading

- `threading.Thread(target=None, name=None, args=(), kwargs={}, daemon=None)` - создания экземпляра объекта потока. (Только ключевые аргументы)
  - `target` - целевая функция (вызываемый объект), которую будет выполнять этот поток
  - `name` -  имя потока
  - `args`, `kwargs` - позиционные и именованные аргументы для нашей целевой функции, причем args указывается через кортеж или список; 
  - `daemon` - флаг, указывающий поведение потока. позволяет создавать демонический поток (выполнение потока как службы в фоне, который можно не дожидаться)

 1. Для запуска вызываем метод .start()
 2. `MainThread` - главный поток
 3. Метод `join()` блокирует работу только того потока, который его вызвал. Остальные потоки продолжают свою работу. Таким образом join-ы, позволяют дождаться завершения дополнительных потоков и, например, позволяют организовывать обработку общего результата от многих запущенных потоков. Блокируем работу потока, который вызвал join до завершения работы потока, которого ждем и все тут.


`threading.active_count()` - возвращает количество активных потоков (целое число);
`threading.current_thread()` - возвращает текущий поток, соответствующий потоку выполнения вызывающего объекта.
`threading.main_thread()` - возвращает главный поток. По умолчанию основным потоком является поток, из которого был запущен интерпретатор Python.
`Thread.name` - возвращает (и задает) имя потока;
`Thread.is_alive()` - проверяет поток на активность, возвращает True или False.
`threading.get_ident()` - возвращает ненулевое целое число, которое однозначно идентифицирует текущий поток среди других потоков, существующих одновременно. Может использоваться при индексации данных потока, может служить ключом в коллекции данных потока. Идентификаторы потока могут быть повторно назначены при выходе из потока и создании другого потока.
`threading.get_native_id()` - тоже идентификатор, но этот id назначается операционной системой и он может быть использован для идентификации конкретного потока в пределах системы. Поток операционной системы часто называют нативным (native), отсюда и название функции идентификатора. Этот системный идентификатор также может называться интегральным идентификатором.
`threading.enumerate()` - возвращает список всех активных (живых) потоков.
`threading.stack_size([size])` - возвращает размер стека, используемый при создании новых потоков. И изменяет размер стека. Необязательный аргумент size указывает размер стека, который будет использоваться для создаваемых впоследствии потоков, и должен быть равен 0 (по умолчанию) при использовании настроек платформы или положительному целочисленному значению не менее 32768. Если size не указан, то используется 0. Если изменение размера стека потока не поддерживается, возникает ошибка RuntimeError. Если указанный размер стека недействителен, возникает ошибка ValueError и размер стека не изменяется.

`threading.excepthook(args, /)` - обрабатывает не перехваченные исключения, вызванные в методе run() потока. Обратите внимание, в функцию обязательно передается один аргумент args. Всегда, даже если Вы не намерены его использовать. Нельзя вызывать функцию threading.excepthook() без аргумента. Это приведет к ошибке:
- TypeError: custom_hook() takes 0 positional arguments but 1 was given.
- Аргумент args имеет следующие атрибуты:
  - `exc_type` - тип исключения;
  - `exc_value` - значение исключения (сообщение исключения), может быть None;
  - `exc_traceback` - трассировка исключения (трассировка стека исключения), может быть None. Представляет собой список фреймов выполнения программы, начиная с точки возникновения исключения и возвращающийся до корневого фрейма (главной программы). Каждый фрейм содержит информацию о вызванной функции, файле и строке кода, где произошло исключение;
  - `exc_thread` - поток, который вызвал исключение, может быть None.

deamon

False
![image](https://github.com/user-attachments/assets/fab3f125-0900-4b80-9c79-f5bf220cce15)


True
![image](https://github.com/user-attachments/assets/f994aa99-c718-47b0-a429-197d9f95d65a)


# Обработка исключений

```
import threading

def error_except(args):
    exc_type, exc_value, exc_traceback, exc_thread = args
    print(f'{exc_thread.name}, {exc_type.__name__}, {exc_value}')


threading.excepthook = error_except
```


# Переопределение потоков

```
import threading


class PrintThread(threading.Thread):  # наследуем оригинальный класс Thread

    def __init__(self, text): 
        super().__init__()
        self.text = text
        # выведите на печать количество активных потоков

    def run(self):  # переопределение метода run
        # выведите на печать количество активных потоков
        print(self.text)


print_thread = PrintThread("Очень простой но бесполезный пример работы отдельного потока")
print_thread.start()
```

Получить результат работы

```
y_thread_1 = MyNewThread(new_arg)
my_thread_1.start()
my_thread_1.join()
res = my_thread_1.result
```

# Очереди

- `queue.Queue(maxsize=0)` - создает очередь FIFO, где maxsize - это целое число, которое устанавливает верхний предел количества элементов, которые могут быть помещены в очередь. Вставка нового элемента будет заблокирована после достижения этого размера. Если maxsize меньше или равен нулю - размер очереди не ограничен.
```
import queue

my_queue = queue.Queue(maxsize=10) # указали ограничение размера в 10 элементов
```

- `queue.LifoQueue(maxsize=0)` создает очередь LIFO

```
import queue

my_queue = queue.LifoQueue(10)
```

- `queue.PriorityQueue(maxsize=0)` создает очередь с приоритетом.  В такой очереди первыми извлекаются объекты с наименьшим значением. Для возможности выбора минимального, объекты в очереди должны иметь возможность сравнения. При этом есть два варианта:
  - объекты, добавляемые в приоритетную очередь обязательно должны иметь метод сравнения ("магический" метод __lt__() для оператора меньше <). Об этом обязательно нужно помнить, если в очереди планируется использовать объекты собственных типов;
  - использовать вспомогательный элемент, например кортеж. В очередь добавляется не просто объект, а кортеж с двумя элементами: (уникальный приоритет, объект). Тогда выбор минимального объекта в очереди для извлечения будет происходить согласно уникальному приоритету. В качестве уникального приоритета проще всего использовать числа.

 ```
import queue

my_queue = queue.PriorityQueue()  # без ограничения по размеру
```

- `SimpleQueue` - В отличие от Queue она:
  - Не предоставляет возможности для ограничения размера очереди и не блокирует потоки при размещении (добавлении) элементов в очереди;
  - не предусматривает работу с задачами;

```
import queue

my_queue = queue.SimpleQueue()
```

Методы работы с очередями:
- `Queue.put(item, block=True, timeout=None)` - размещает (добавляет) элемент item в очереди. Похож на метод append для списка.
  - с аргументами по умолчанию добавление элемента в очередь блокируется до тех пор, пока не освободится свободный слот;
  - если block=True, а таймаут timeout задан положительным числом, то добавление элемента в очередь блокируется на максимальное время ожидания timeout. Если в течение этого времени не было свободного места в очереди, то возбуждается исключение queue.Full (см. ниже). Если в очереди было место для добавления элемента - никакого блокирования не происходит.;
  - если  block=False, то таймаут игнорируется. Если свободный слот не доступен, то попытка добавления элемента возбуждает исключение queue.Full.
- `Queue.put_nowait(item)` - размещает элемент в очереди без блокировки и ожиданий.
- `queue.Full` - исключение, которое возникает, когда неблокирующая функция put() или put_nowait() вызывается для заполненной очереди (очереди с размером равном maxsize).
- `Queue.get(block=True, timeout=None)` - возвращает (получает) элемент item из очереди и сразу же удаляет этот элемент из очереди, т.е. извлекает элемент. Похож на метод pop для списка.
  - с аргументами по умолчанию при попытке извлечения элемента происходит блокировка, пока элемент не станет доступен в очереди (т.е. пока не будет что извлекать);
  - если таймаут timeout задан положительным числом, то извлечение элемента из очереди блокируется на максимальное время ожидания timeout. Если в течение этого времени ни один элемент не был доступен для извлечения, то возбуждается исключение queue.Empty. Если в очереди был элемент для извлечения - никакого блокирования не происходи.
  - если  block=False, то timeout игнорируется. Если очередь пустая, то попытка извлечения элемента возбуждает исключение queue.Empty.
- `Queue.get_nowait()` - эквивалентен вызову метода Queue.get(False), т.е. вызову с параметрами block=False, timeout=None. При работе с методами без ожидания и блокировок нужно быть осторожным, большой риск получить конфликты и ошибки при работе с двумя и более потоками - участниками.
- `queue.Empty` - возникает, когда неблокирующая функция get() или get_nowait() вызывается для пустой очереди.
- `Queue.qsize()` - возвращает примерный размер очереди (целое число). Примерный, т.к. размер после получения может сразу же изменится в результате работы (обращения к очереди) другого потока. Нельзя использовать для определения "крайних" состояний очередей: полная очередь, пустая очередь. Для этого есть специальные методы определения;
  - `Queue.empty()` - возвращает True, если очередь пустая. Иначе - False;
  - `Queue.full()` - по аналогии, возвращает True, если очередь полная. Иначе - False.


### Локальные переменные

```
import threading

stor = threading.local() # Создаем объект локального хранилища
stor.a = 100  # Создаем атрибут, доступный только Main потоку и передаем ему значение
```

Локальные переменные для каждого потока свои. Внутри реализован словарь где ключ - имя потока, значение - его локальные переменные

Можно самому написать class унаследовавшись от threading.local()

```
from threading import Thread, local

# где-то определен stor_local = local()


def make_msg(stor_local: local):
    authentication = hasattr(stor_local, "authentication")
    fileno = None
    date_and_time = None
    if hasattr(stor_local, "fileno"):
        fileno = stor_local.fileno
    if hasattr(stor_local, "dt"):
        date_and_time = stor_local.dt
    return f"{authentication=}, {fileno=}, {date_and_time=}"
```
