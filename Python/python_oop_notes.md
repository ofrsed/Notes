
`Класс` — это шаблон кода, по которому создаются объекты. Класс описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением.

`Объект` — это программная сущность, обладающая определённым состоянием (атрибуты) и поведением (методы). Объект также можно считать конкретным представителем класса.

Принципы 
Абстракция - это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. 
Инкапсуляция - объединение атрибутов и методов в одном объекте и сокрытие данных, то есть невозможность напрямую получить доступ к внутренней структуре объекта

Наследование — способ создания класса на основе уже существующего, при котором дочерний класс заимствует атрибуты и методы родительского класса, а также добавляет собственные.

Полиморфизм - Объекты разных классов, с разной внутренней реализацией, могут иметь одинаковые интерфейсы. 

# Атрибуты, свойства и методы
## Атрибуты объектов и классов
`dir()` - получение списка всех атрибутов и методов объекта
`__doc__` - получить строку документации
`__dict__` - получает доступ к атрибутам объекта
`__class__` - получить тип объекта

## Функции, работающие с атрибутами
- `getattr()` - возвращает значение атрибута name объекта `obj`. Если объект `obj` не имеет атрибута `name`, возвращается значение по умолчанию `default`. Если значение по умолчанию не указано, возбуждается исключение AttributeError
  - `obj` — объект
  - `name` — имя атрибута
  - `default` — значение по умолчанию
 
- `setattr()` - Функция устанавливает объекту `obj` атрибут `name` со значением `value`. Если объект `obj` уже имеет атрибут `name`, его значение перезаписывается
  - `obj` — объект
  - `name` — имя атрибута
  - `default` — значение по умолчанию
 
- `delattr()` удаляет атрибут name у объекта `obj`. Если объект не имеет атрибута `name`, возбуждается исключение AttributeError.
  - `obj` — объект
  - `name` — имя атрибута
 
- `hasattr()` Функция возвращает True, если объект `obj` имеет атрибут `name`, или False в противном случае.
  - `obj` — объект
  - `name` — имя атрибута
 
  ## Методы экземпляра класса
  __init__() - инициализирует атрибуты объекта. Сразу после создания объекта исполняется метод __init__(), и параметру self автоматически присваивается объект, который был только что создан, что позволяет тут же наделить его необходимыми атрибутами.

## модификаторы доступа и аксессоры
Модификаторы доступа
`self.name = name` - Публичный. Публичные атрибуты доступны для работы вне класса

`self._name = name` - Защищенный. Доступ к защищенным атрибутам возможен только внутри текущего класса, а также внутри унаследованных от него классов

`self.__name = name` - Приватный. Приватные атрибуты недоступны извне — с ними можно работать только внутри текущего класса  (дает новое имя переменной _Класс__переменная)


## свойства, функция property()

На практике широко принято делать все атрибуты класса и объекта защищенными или приватными, и предоставлять публичные методы для доступа к этим атрибутам и для их изменения. Так гарантируется, что класс или объект, владеющий этими атрибутами, будет держать под контролем все вносимые в них изменения.

`getter` / Геттеры — метод, который возвращает значение атрибута и при этом не изменяет его

`setter` / Сеттеры — метод, который сохраняет значение в атрибуте или меняет его

`deleter` / Делитер — метод, удаляющий атрибут из объекта

- `property()` - возвращает специальный объект `property` — свойство на основе переданных геттера, сеттера и делитера.
  - `fget` — функция для получения значения атрибута (геттер)
  - `fset` — функция для установки значения атрибута (сеттер)
  - `fdel` — функция для удаления атрибута (делитер)
  - `doc` — строка документации
 
```
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    def get_info(self):
        return self.breed + ' ' + self.name
    
    def set_info(self, info):
        self.breed, self.name = info.split()
    
    info = property(get_info, set_info)
```
## Декоратор @property
```
class Cat:
    def __init__(self, name):
        self._name = name                               # имя кошки

    @property
    def name(self):                                     # геттер свойства name
        return self._name

    @name.setter
    def name(self, name):                               # сеттер свойства name
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):                                     # делитер свойства name 
        del self._name
```

## декораторы @classmethod, @staticmethod и @singledispatchmethod

`@classmethod` - Такие методы имеют возможность менять состояние класса, что в свою очередь отражается на всех экземплярах данного класса. 
```
class MyClass:
    @classmethod
    def my_classmethod(cls):
        print('Это метод класса')
        print(cls)


MyClass.my_classmethod()
```
`@staticmethod` - статические методы не могут изменять ни состояние объекта, ни состояние класса. Статические методы можно считать обычными функциями, которые помещены в класс для удобства. Чаще всего это какой-то вспомогательный код, предназначенный для внутреннего использования.
```
class MyClass:
    @staticmethod
    def my_staticmethod():
        print('Это статический метод')


MyClass.my_staticmethod()
```

`@singledispatchmethod` - функция одиночной диспетчеризации. Данный способ позволяет определить несколько инициализаторов и выборочно их использовать в зависимости от типа первого переданного в них аргумента.
```
from functools import singledispatchmethod


class Cat:
    @singledispatchmethod
    def __init__(self, breed, name, age):
        self.breed = breed
        self.name = name
        self.age = age

    @__init__.register(list)
    @__init__.register(tuple)
    def _from_list_tuple(self, data):
        self.breed, self.name, self.age = data


cat1 = Cat(('Британский', 'Кемаль', 1))
cat2 = Cat(['Манчкин', 'Роджер', 1])

print(cat1.breed, cat1.name, cat1.age)
print(cat2.breed, cat2.name, cat2.age)
```

# Магические методы
Магические методы – это общий термин, относящийся к специальным методам в классах Python. Для них нет единого определения, поскольку их применение разнообразно. Магические методы, как правило, добавляют в класс специальный функционал. Они всегда обрамлены двумя нижними подчеркиваниями, например, __init__().

Магические методы не предназначены для прямого вызова, однако их вызов происходит автоматически при определенных действиях. Например, мы явно не вызываем метод __init__() при создании нового экземпляра класса, но вместо этого данный метод вызывается внутренне. Все, что нам нужно сделать, это реализовать метод внутри класса должным образом.

- `__new__()`
  Первым обязательным аргументом метода __new__() пользовательского класса является сам класс, после которого, как правило, следуют произвольное количество позиционных и именованных аргументов. Дело в том, что аргументы, указываемые при вызове класса, передаются как в метод __init__(), так и в метод __new__().
```
  class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name


cat = Cat.__new__(Cat)
Cat.__init__(cat, 'Кемаль')

print(type(cat))
```

- `__del__()` - финализатор. Вызывается когда ссылки на объект равны 0.
- `str()` `__str__()` -  функция возвращает строковое представление объекта в неформальном виде (понятном человеку)
- `repr()` `__repr__()` - в формальном виде (понятном интерпретатору Python)

| en | ru | condition | oop | comm |
| ----- | ----- | ----- | ----- | ----- |
| equal | равно | a == a | `a.__eq__(a)` | Сравнение на равенство |
| not equal | не равно | a != a | `a.__ne__(a)` | Сравнение на неравенство |
| less than | меньше чем | a < a | `a.__lt__(a)` | Сравнение на меньше |
| greater than | больше чем | a > a | `a.__gt__(a)` | Сравнение на больше |
| less than or equal | Меньше или равно | a<=a | `a.__le__(a)` | Меньше или равно |
| greater than or equal | больше или равно | a>=a | `a.__ge__(a)` | Больше или равно |


- ``
- ``
- ``
- ``
- ``
- ``
- ``
- ``
- ``
- ``
- ``
- `` 
  
