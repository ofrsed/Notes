___Объектно-ориентированное программирование__

- [Введение в ООП](#Введение-в-ООП)
- [Атрибуты, свойства и методы](#Атрибуты,-свойства-и-методы)
  - [Атрибуты объектов и классов](#Атрибуты-объектов-и-классов)
  - [Функции, работающие с атрибутами](#Функции,-работающие-с-атрибутами)
  - [Модификаторы доступа и аксессоры](#Модификаторы-доступа-и-аксессоры)
  - [Свойства, функция property()](#свойства,-функция-property())
  - [Декоратор @property](#Декоратор-@property)
  - [Декораторы @classmethod, @staticmethod и @singledispatchmethod](#декораторы-@classmethod,-@staticmethod-и-@singledispatchmethod)

- [Магические методы](#Магические-методы)
  - [Унарные операторы](#Унарные-операторы)
  - [Арифметические операции](#Арифметические-операции)
  - [Вызываемые объекты](#Вызываемые-объекты)
  - [Преобразование типов](#Преобразование-типов)
  - [Работа с атрибутами объектов](#Работа-с-атрибутами-объектов)
  - [Хеширование объектов](#Хеширование-объектов)
- [Протоколы](#Протоколы)
  - [Итерируемые объекты и итераторы](#Итерируемые-объекты-и-итераторы)
  - [Протокол последовательностей](#Протокол-последовательностей)
  - [Протокол контекстных менеджеров](#Протокол-контекстных-менеджеров)
  - [Декоратор @contextmanager](#Декоратор-@contextmanager)
  - [Дескрипторы](#Дескрипторы)
- [Наследование](#Наследование)
  - [Дерево исключений](#Дерево-исключений)
  - [Абстрактный классы](#Абстрактный-классы)
- [Полиморфизм](#Полиморфизм)



# Введение в ООП
`Класс` — это шаблон кода, по которому создаются объекты. Класс описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением.

`Объект` — это программная сущность, обладающая определённым состоянием (атрибуты) и поведением (методы). Объект также можно считать конкретным представителем класса.

Принципы 
Абстракция - это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. 
Инкапсуляция - объединение атрибутов и методов в одном объекте и сокрытие данных, то есть невозможность напрямую получить доступ к внутренней структуре объекта

Наследование — способ создания класса на основе уже существующего, при котором дочерний класс заимствует атрибуты и методы родительского класса, а также добавляет собственные.

Полиморфизм - Объекты разных классов, с разной внутренней реализацией, могут иметь одинаковые интерфейсы. 

# Атрибуты, свойства и методы

`dir()` - получение списка всех атрибутов и методов объекта
`__doc__` - получить строку документации
`__dict__` - получает доступ к атрибутам объекта
`__class__` - получить тип объекта

## Функции, работающие с атрибутами
- `getattr()` - возвращает значение атрибута name объекта `obj`. Если объект `obj` не имеет атрибута `name`, возвращается значение по умолчанию `default`. Если значение по умолчанию не указано, возбуждается исключение AttributeError
  - `obj` — объект
  - `name` — имя атрибута
  - `default` — значение по умолчанию
 
- `setattr()` - Функция устанавливает объекту `obj` атрибут `name` со значением `value`. Если объект `obj` уже имеет атрибут `name`, его значение перезаписывается
  - `obj` — объект
  - `name` — имя атрибута
  - `default` — значение по умолчанию
 
- `delattr()` удаляет атрибут name у объекта `obj`. Если объект не имеет атрибута `name`, возбуждается исключение AttributeError.
  - `obj` — объект
  - `name` — имя атрибута
 
- `hasattr()` Функция возвращает True, если объект `obj` имеет атрибут `name`, или False в противном случае.
  - `obj` — объект
  - `name` — имя атрибута
 
  ## Методы экземпляра класса
  __init__() - инициализирует атрибуты объекта. Сразу после создания объекта исполняется метод __init__(), и параметру self автоматически присваивается объект, который был только что создан, что позволяет тут же наделить его необходимыми атрибутами.

## модификаторы доступа и аксессоры
Модификаторы доступа
`self.name = name` - Публичный. Публичные атрибуты доступны для работы вне класса

`self._name = name` - Защищенный. Доступ к защищенным атрибутам возможен только внутри текущего класса, а также внутри унаследованных от него классов

`self.__name = name` - Приватный. Приватные атрибуты недоступны извне — с ними можно работать только внутри текущего класса  (дает новое имя переменной _Класс__переменная)


## свойства, функция property()

На практике широко принято делать все атрибуты класса и объекта защищенными или приватными, и предоставлять публичные методы для доступа к этим атрибутам и для их изменения. Так гарантируется, что класс или объект, владеющий этими атрибутами, будет держать под контролем все вносимые в них изменения.

`getter` / Геттеры — метод, который возвращает значение атрибута и при этом не изменяет его

`setter` / Сеттеры — метод, который сохраняет значение в атрибуте или меняет его

`deleter` / Делитер — метод, удаляющий атрибут из объекта

- `property()` - возвращает специальный объект `property` — свойство на основе переданных геттера, сеттера и делитера.
  - `fget` — функция для получения значения атрибута (геттер)
  - `fset` — функция для установки значения атрибута (сеттер)
  - `fdel` — функция для удаления атрибута (делитер)
  - `doc` — строка документации
 
```
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    def get_info(self):
        return self.breed + ' ' + self.name
    
    def set_info(self, info):
        self.breed, self.name = info.split()
    
    info = property(get_info, set_info)
```
## Декоратор @property
```
class Cat:
    def __init__(self, name):
        self._name = name                               # имя кошки

    @property
    def name(self):                                     # геттер свойства name
        return self._name

    @name.setter
    def name(self, name):                               # сеттер свойства name
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):                                     # делитер свойства name 
        del self._name
```

## декораторы @classmethod, @staticmethod и @singledispatchmethod

`@classmethod` - Такие методы имеют возможность менять состояние класса, что в свою очередь отражается на всех экземплярах данного класса. 
```
class MyClass:
    @classmethod
    def my_classmethod(cls):
        print('Это метод класса')
        print(cls)


MyClass.my_classmethod()
```
`@staticmethod` - статические методы не могут изменять ни состояние объекта, ни состояние класса. Статические методы можно считать обычными функциями, которые помещены в класс для удобства. Чаще всего это какой-то вспомогательный код, предназначенный для внутреннего использования.
```
class MyClass:
    @staticmethod
    def my_staticmethod():
        print('Это статический метод')


MyClass.my_staticmethod()
```

`@singledispatchmethod` - функция одиночной диспетчеризации. Данный способ позволяет определить несколько инициализаторов и выборочно их использовать в зависимости от типа первого переданного в них аргумента.
```
from functools import singledispatchmethod


class Cat:
    @singledispatchmethod
    def __init__(self, breed, name, age):
        self.breed = breed
        self.name = name
        self.age = age

    @__init__.register(list)
    @__init__.register(tuple)
    def _from_list_tuple(self, data):
        self.breed, self.name, self.age = data


cat1 = Cat(('Британский', 'Кемаль', 1))
cat2 = Cat(['Манчкин', 'Роджер', 1])

print(cat1.breed, cat1.name, cat1.age)
print(cat2.breed, cat2.name, cat2.age)
```

# Магические методы
Магические методы – это общий термин, относящийся к специальным методам в классах Python. Для них нет единого определения, поскольку их применение разнообразно. Магические методы, как правило, добавляют в класс специальный функционал. Они всегда обрамлены двумя нижними подчеркиваниями, например, __init__().

Магические методы не предназначены для прямого вызова, однако их вызов происходит автоматически при определенных действиях. Например, мы явно не вызываем метод __init__() при создании нового экземпляра класса, но вместо этого данный метод вызывается внутренне. Все, что нам нужно сделать, это реализовать метод внутри класса должным образом.

- `__new__()`
  Первым обязательным аргументом метода __new__() пользовательского класса является сам класс, после которого, как правило, следуют произвольное количество позиционных и именованных аргументов. Дело в том, что аргументы, указываемые при вызове класса, передаются как в метод __init__(), так и в метод __new__().
```
  class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name


cat = Cat.__new__(Cat)
Cat.__init__(cat, 'Кемаль')

print(type(cat))
```

- `__del__()` - финализатор. Вызывается когда ссылки на объект равны 0.
- `str()` `__str__()` -  функция возвращает строковое представление объекта в неформальном виде (понятном человеку)
- `repr()` `__repr__()` - в формальном виде (понятном интерпретатору Python)

| en | ru | condition | oop | comm |
| ----- | ----- | ----- | ----- | ----- |
| equal | равно | a == a | `a.__eq__(a)` | Сравнение на равенство |
| not equal | не равно | a != a | `a.__ne__(a)` | Сравнение на неравенство |
| less than | меньше чем | a < a | `a.__lt__(a)` | Сравнение на меньше |
| greater than | больше чем | a > a | `a.__gt__(a)` | Сравнение на больше |
| less than or equal | Меньше или равно | a<=a | `a.__le__(a)` | Меньше или равно |
| greater than or equal | больше или равно | a>=a | `a.__ge__(a)` | Больше или равно |

 константу NotImplemented рекомендуется возвращать в методе __eq__(), если сравнение для объектов каких-либо типов не определено.
 
если метод не определен, то равенство является проверкой на иденчитность

`from functools import total_ordering  \   @total_ordering` - позволяет определить лишь метод `__eq__` и один из методов lt \ lt \ gt \ ge. Все недостающий методы декоратор определит самостоятельно

## Унарные операторы

- `__pos__()` - определяет поведение для унарного плюса `print(+num)`
- `__neg__()` - определяет поведение для унарного минуса `print(-num)`
- `__invert__()` -  определяет поведение для оператора инвертирования `print(~num)`
- `__abs__()` -  определяет поведение для встроенной функции `abs()`
- `__round__()` - определяет поведение для встроенной функции round(); помимо экземпляра класса метод принимает необязательный аргумент n, который, как правило, означает количество знаков после запятой после округления
- `__trunc__()` -  определяет поведение для функции trunc() из модуля math
- `__floor__()` - определяет поведение для функции floor() из модуля math
- `__ceil__()` - определяет поведение для функции ceil() из модуля math

## Арифметические операции

- `__add__()` - определяет поведение для сложения (оператор +)
- `__sub__()` - определяет поведение для вычитания (оператор -)
- `__mul__()` - определяет поведение для умножения (оператор *)
- `__truediv__()` - определяет поведение для обычного деления (оператор /)
- `__floordiv__()` - определяет поведение для целочисленного деления (оператор //)
- `__mod__()` - определяет поведение для деления по модулю (оператор %)

Операторы с префиксом r отличаются лишь тем, что применяются к разным операндам `x.__add__(y)` `y.__radd__(x)`

- `__radd__()` - определяет поведение для сложения (оператор +)
- `__rsub__()` - определяет поведение для вычитания (оператор -)
- `__rmul__()` - определяет поведение для умножения (оператор *)
- `__rtruediv__()` -  определяет поведение для обычного деления (оператор /)
- `__rfloordiv__()` - определяет поведение для целочисленного деления (оператор //)
- `__rmod__()` - определяет поведение для деления по модулю (оператор %)

- `__iadd__()` - определяет поведение для сложения (оператор +=)
- `__isub__()` - определяет поведение для вычитания (оператор -=)
- `__imul__()` - определяет поведение для умножения (оператор *=)
- `__itruediv__()` - определяет поведение для обычного деления (оператор /=)
- `__ifloordiv__()` - определяет поведение для целочисленного деления (оператор //=)
- `__imod__()` - определяет поведение для деления по модулю (оператор %=)

- `__pow__()` - Возведение в степень ( ** )
- `__divmod__()` - ?
- `__lshift__()` - определяет поведение для двоичного сдвига влево (оператор <<)
- `__rshift__()` - определяет поведение для двоичного сдвига вправо (оператор >>)
- `__and__()` - определяет поведение для двоичного И (оператор &)
- `__or__()` - определяет поведение для двоичного ИЛИ (оператор |)
- `__xor__()` - определяет поведение для двоичного XOR, (оператор ^)

## Вызываемые объекты

- `__call__()` - позволяет экземплярам класса вести себя так, как будто они функции, то есть мы можем вызывать их, передавать их в функции, которые ожидают в качестве аргумента функцию, и так далее.

## Преобразование типов

- `__int__()` - определяет поведение экземпляра при передаче в функцию `int()`. Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип `int`
- `__float__()` - определяет поведение экземпляра при передаче в функцию `float()`. Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип `float`
- `__complex__()` - определяет поведение экземпляра при передаче в функцию complex(). Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип complex
- `__bool__()` - Вызов метода (в определенных случаях `__len__()`) происходит во время любых логических приведений. Например, при проверке на истинность с помощью условного оператора `if`.

## Работа с атрибутами объектов

- `__getattribute__()` - вызывается при обращении к любому атрибуту
- `__getattr__()` - вызывается при обращении к несуществующему атрибуту
- `__setattr__()` - вызывается при установке атрибута или изменении его значения
- `__delattr__()` - вызывается при удалении любого атрибута

## Хеширование объектов

Хеш — функция, преобразующая данные произвольного размера в последовательность фиксированного размера

Коллизия — у двух разных наборов хеш-значения совпадают

Детерминированность — любая хеш-функция для одинаковых входных данных возвращает одинаковый результат

list, set, dict — не хешируемые, т.к. изменяемые

- Свойства идесльной Хеш-функции
  - Детерменированность — одинаковые входные данные всегда дают одинаковые значения
  - Высокая скорость ХЕШирования
  - однонаправленность — невозможно получить исходное сообщение, зная его ХЕШ
  - Наличие лавинного эффекта — минимальное изменение значения приводит к координальному изменению ХЕШа
  - отсутствие коллизий — невозможно найти одинаковый ХЕШ у двух разных сообщений

- `hash()` - используется для вычисления хеш-значения объекта

# Протоколы

## Итерируемые объекты и итераторы


- `__iter__()` - преобразует итерируемый объект в итератор
- `__next__()` - обеспечивает выдачу очередного элемента.

## Протокол последовательностей
- __len__()`` - определяет поведение при передаче в функцию `len()`, возвращает количество элементов в последовательности
- `__getitem__()` - определяет поведение при доступе к элементу, используя синтаксис `self[key]`
- `__iter__()` - определяет поведение при передаче в функцию `iter()`, возвращает итератор для последовательности
- `__contains__()` -  определяет поведение при проверке на принадлежность с помощью оператора `in` (`not in`)
- `__setitem__()` - определяет поведение при присваивании значения элементу, используя синтаксис `self[key] = value`
- `__delitem__()` - определяет поведение при удалении элемента с помощью оператора `del`
- `__reversed__()` - reversed

## Протокол контекстных менеджеров
- `__enter__()` - вводит контекст и при необходимости возвращает некоторый объект. Значение, возвращаемое этим методом, привязывается к переменной в предложении `as` оператора `with`
- `__exit__()` - предоставляет выход из контекста и возвращает логический флаг (тип `bool`), указывающий на то, следует ли подавлять возбужденное исключение. При возбуждении исключения во время выполнения тела блока `with`, аргументы содержат тип исключения `exc_type`, объект исключения `exc_value` и информацию о трассировке `traceback`. В противном случае все три аргумента равны `None`
  - `exc_type` — тип исключения
  - exc_value — объект исключения
  - `traceback` - информ о трассировке
```
class WritableTextFile:
    def __init__(self, path):
        self.path = path

    def __enter__(self):
        self.file = open(self.path, mode='w', encoding='utf-8')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()
```

## Декоратор @contextmanager

```
from contextlib import contextmanager

@contextmanager
def custom_context_manager():
    print('Вход в контекстный менеджер...')
    try:
        yield 'Python generation!'
    except IndexError as error:
        print(f'Тип возбужденного исключения: {type(error)}')
        print(f'Текст исключения: {error}')
    except:
        raise           # если исключение не планируется подавлять, оно должно быть возбуждено повторно
    finally:
        print('Выход из контекстного менеджера...')
```

## Дескрипторы

`None`

# Наследование

Наследование — механизм получения новых классов из уже существующих

Класс от которого наследуется — родительский, базовый, суперкласс

Класс, который наследуется  - дочерний, наследник, подкласс

- Плюсы;
  - повторное использование кода
  - снижение затрат на разработку (изменяя базовый класс меняются дочерние)

- `__base__` - позволяет получить родительский класс текущего класса
- `issubclass ( A, B ) ` - проверка на прямое или косвенное наследование
- `isinstance ( obj, A )` - позволяет проверить, является ли объект прямым или косвенным экземпляром некоторого класса
- `super( cls (чей родитель), obj) ` - обращаемся к родительскому классу (прокси-объект)
- `mro()  (__mro__)  ` - метод для получения MRO (Method Resolution Order), возвращает список родителей класса, в том порядке, в котором будет производиться поиск методов

Правила:
1. Родители не могут идти раньше детей
2. Порядок ровно тот, который указывался
3. Если у элемента есть необработанный ребенок — он не добавляется


## Дерево исключений

- BaseException
  - SystemExit
  - KeyboardInterrupt
  - GeneratorExit
  - Exception
    - StopIteration
    - StopAsyncIteration
    - ArithmeticError
      - FloatingPointError
      - OverflowError
      - ZeroDivisionError
    - AssertionError
    - AttributeError
    - BufferError
    - EOFError
    - ImportError
      - ModuleNotFoundError
    - LookupError
      - IndexError
      - KeyError
    - MemoryError
    - NameError
      - UnboundLocalError
    - OSError
      - BlockingIOError
      - ChildProcessError
        - ConnectionError
        - BrokenPipeError
        - ConnectionAbortedError
        - ConnectionRefusedError
vConnectionResetError
vFileExistsError
      - FileNotFoundError
      - InterruptedError
      - IsADirectoryError
      - NotADirectoryError
      - PermissionError
      - ProcessLookupError
      - TimeoutError
    - ReferenceError
    - RuntimeError
      - NotImplementedError
      - RecursionError
    - SyntaxError
      - IndentationError
        - TabError
    - SystemError
    - TypeError
    - ValueError
      - UnicodeError
        - UnicodeDecodeError
        - UnicodeEncodeError
        - UnicodeTranslateError
    - Warning
      - DeprecationWarning
      - PendingDeprecationWarning
      - RuntimeWarning
      - SyntaxWarning
      - UserWarning
      - FutureWarning
      - ImportWarning
      - UnicodeWarning
      - BytesWarning
       - ResourceWarning

# Абстрактный классы

Абстрактный классы - класс, определяющий интерфейс, но не реализовывающий его.

```
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def move(self):
        pass

    @abstractmethod
    def sound(self):
        pass
```

Определяется с помощью ABC

-могут использовать реализованные методы, но их все равно нужно будет переопределить в дочернем классе
-может содержать и обычные методы, которые можно не переопределять

# Полиморфизм

Объекты с разной реализацией могут иметь разные интерфейсы

есть один интерфейс ( + ), но разные реализации („abc“ + „def“, 1 + 1, [1,2] + [3,4])

- `` -
- `` -
- `` -
- `` -
