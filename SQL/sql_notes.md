SQL 
- [Фильтрация-данных](#Фильтрация-данных)
- [Метасимволы](#Метасимволы)
- [Текстовые функции](#Текстовые-функции)
- [Числовые функции](#Числовые-функции)
- [Функции даты и времени](#Функции-даты-и-времени)
- [Дополнительные функции](#Дополнительные-функции)
- [Условные конструкции](#Условные-конструкции)
- [Агрегатные-функции](#Агрегатные-функции)
- [Группировка данных](#Группировка-данных)
- [Подзапросы](#Подзапросы)


## Первичные ключи
### Сурогатные - дополнительное служебное поле, значения которого, в отличие от естественного ключа, не образуются на основе каких-либо данных, а генерируются искусственно.
### Естественные - ключ, содержит полезную информацию об описываемых сущностях
Внешний ключ может ссылаться как на первичный ключ другой таблицы, так и той, в которой он находится. Во втором случае внешний ключ называют `рекурсивным`.

## Виды связей
### Один к одному
### Один ко многим
### Многие ко многим. Связь между таблицами устанавливается путем создания промежуточной таблицы

```
SELECT DISTINCT artist FROM Songs; - извлекает только уникальные записи
```
```
SELECT trackname FROM Songs LIMIT 3 OFFSET 2; - получить первые 3 записи начиная со 2-й (offset)
limit – количество строк для извлечение,
offset – начальная точка
```
```
SELECT artist, trackname FROM Songs ORDER BY release_date; - сортировка
```
```
SELECT title FROM Songs ORDER BY title ASC; - то же, ASC – по возрастанию (не обязательно)
```
```
SELECT id, artist, trackname FROM Songs ORDER BY artist, id DESC; - сортировка в порядке убывания
DESCENDING – убывание,
ASCENDING - возрастание
```

## Фильтрация данных 
```SELECT * FROM Songs WHERE artist = 'The Sounds' ORDER BY streams;```
| Оператор | Проверка |
| --- | --- |
| `=` | Равенство |
| `<=>` | Эквивалентность |
| `!= или <>` | Неравенство |
| `<` | Меньше |
| `<=` | Меньше или равно |
| `>` | Больше |
| `>=` | Больше или равно |
| `BETWEEN` | Вхождение в диапазон |
| `IS NULL` | Значение NULL |
| `IS NOT NULL` | Не значение NULL |

```
SELECT trackname, artist, streams FROM Songs WHERE streams BETWEEN 50000 AND 100000;
```

```
SELECT place, trackname, artist 
FROM Songs 
WHERE place <= 4 
ORDER BY place 
LIMIT 2;
```
Оператор
IN , NOT IN \ NOT \ AND \ OR

## Метасимволы
```
SELECT trackname, artist FROM Songs WHERE artist LIKE 'The%';
SELECT trackname, artist FROM Songs WHERE trackname LIKE '___ %'; - любой символ
```
Like - не учитывает регистр, чтобы учитывал - WHERE trackname LIKE CAST('%You%' AS BINARY);
или BINARY(trackname) == LOWER(trackname) 

## Текстовые функции
Сравненеие строк просиходи без учета регистра
- `CHAR_LENGTH()` - кол-во символов
- `LOWER() \ UPPER()` - нижний \ верхний регистр
- `LTRIM() \ RTRIM()` -  отсечения ведущих пробелов
- `REVERSE()` - реверс
- `REPEAT()` повторяет строку заданное число раз
  -	str — исходная строка
  -	count — количество повторений
- `LPAD() \ RPAD()` дополняет строку справа другой строкой до заданной длины
  -	str — исходная строка
  -	len — желаемая длина строки
  -	padstr — дополняющая строка
- `LEFT() \ RIGHT()` - извлечения определенного количества символов из начала \ конца строки
  - str — исходная строка
  - count — количество извлекаемых символов
- `LOCATE()` - используется для определения местоположения подстроки в строке. Функция выполняет поиск подстроки substr в строке str, начиная с позиции start, и возвращает позицию ее первого вхождения. (без учета регистра и с 1, а не с 0. Если ничего нет - вернет 0)
  - substr — искомая подстрока
  - str — исходная строка
  - start — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)
- `REPLACE()` - используется для замены подстроки в строке (если нет подстроки, вернет строку в исходном виде, есть учет регистра)
  - str — исходная строка
  - from_str — заменяемая подстрока
  - to_str — заменяющая подстрока
- `SUBSTRING()` используется для извлечения подстроки из строки (с уч. регистра). Она принимает три аргумента в следующем порядке:
  - str — исходная строка
  - start — позиция первого извлекаемого символа
  - len — длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца)
- `SUBSTRING_INDEX()` используется для извлечения подстроки из строки с помощью разделителя. Она принимает три аргумента в следующем порядке:
  - str — исходная строка
  - delimiter — разделитель
  - count — количество появлений разделителя
- `TRIM` -  удаления всех вхождений подстроки из начала и/или конца строки
```
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>)
  Ключевые слова LEADING, TRAILING и BOTH определяют, откуда будет происходить удаление подстроки:
  - LEADING — из начала строки
  - TRAILING  — из конца строки
  - BOTH — из начала и конца строки
```
`select TRIM( LEADING ' ' from product_name)`

## Числовые функции
- `Операторы DIV` - целочисленное деление (прим. 11 MOD 2)
- `Оператор MOD` - деление с остатком (прим. SELECT 11 MOD 3, 11 % 3,  MOD(11, 3); 
- `ABS()` - модуль числа
- `ROUND()` - округление числа
  - num — число
  - decimals — количество знаков после запятой
- `FLOOR()` - округление в меньшую
- `CEILING()` - округление в большую
- `POW()` -возведение числа в степень 
  - num — число
  - degree — показатель степени
- `SQRT()` - вычисление квадратного корня
- `RAND()` - генерации случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне [0, 1)
- `DEGREES() и RADIANS()` - перевод значения из радиан в градусы\из градусов в радианы
- `PI(), COS(), SIN() и TAN()` -  получения числа пи (6 знаков)\вычисление синуса, косинуса и тангенса соответственно (принимают в радианах)
   `LEAST() и GREATEST()` -  поиск минимального\максимального значения (принимает переменное кол-во не меньше двух)
- `CONV()` - перевод числа из одной системы счисления в другую
  - num — число
  - from_base — система счисления, в которой представлено число
  - to_base — система счисления, в которую нужно перевести число
- `FORMAT()` - для округления и форматирования числа, форматирует его путем разбиения на разряды
  - num — число
  - decimals — количество знаков после запятой

## Функции даты и времени
Временные интервалы
```
INTERVAL 1 YEAR
INTERVAL '10-2' YEAR_MONTH
```

Поддерживаемые единицы измерения - MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR

Составные:
|  |  |
| --- | --- |
| SECOND_MICROSECOND	| секунды.микросекунды | 
| MINUTE_MICROSECOND	| минуты:секунды.микросекунды | 
| MINUTE_SECOND	| минуты:секунды | 
| HOUR_MICROSECOND	| часы:минуты:секунды.микросекунды | 
| HOUR_SECOND	| часы:минуты:секунды | 
| HOUR_MINUTE	| часы:минуты | 
| DAY_MICROSECOND	| дни часы:минуты:секунды.микросекунды | 
| DAY_SECOND	| дни часы:минуты:секунды | 
| DAY_MINUTE	| дни часы:минуты | 
| DAY_HOUR	| дни часы | 
| YEAR_MONTH	| годы-месяцы | 

- `NOW(), CURDATE() и CURTIME()` - получения текущей даты и времени / дату / время
- `UTC_TIMESTAMP(), UTC_DATE() и UTC_TIME()` - получения текущей даты и времени в нулевом часовом поясе / дату / время
- `MAKEDATE()` - используется для создания даты
  - year — год
  - day — номер дня в году
- `MAKETIME()` - используется для создания временного значения
  - hours — часы
  - minutes — минуты
  - seconds — секунды
- `TIME_TO_SEC() и SEC_TO_TIME()` - преобразования временного значения в секунды / секунд во временное значение
- `TO_DAYS() и TO_SECONDS()` - преобразования даты в количество дней /  преобразует дату в количество секунд (от 0000-00-00 00:00:00)
- `LAST_DAY()` - используется для замены дня на последний день месяца

- `DATE() и TIME()` используется для получения даты\времени из даты и времени
- `HOUR(), MINUTE(), SECOND() и MICROSECOND()` - принимает аргументом временное значение, используется для определения количества часов во времени
- `YEAR(), MONTH() и DAY()` - используется для извлечения значения года\месяца\дня из даты.
- `DAYOFYEAR()` - используется для вычисления номера дня в году (от 1 до 366) на основе даты.
- `WEEK()` - используется для вычисления номера недели в году на основе даты. 
- `WEEKDAY()` - используется для вычисления номера дня недели (от 0 до 6) на основе даты.
- `QUARTER()` -  используется для вычисления номера квартала (от 1 до 4) на основе даты. 
- `DAYNAME()` - используется для вычисления названия дня недели на основе даты. 
- `MONTHNAME()` - используется для определения названия месяца на основе даты. 

`SET lc_time_names` = 'ru_RU'; - установить локализацию. Определяет как будет выводиться название дней недели и месяцев

- `ADDDATE() и SUBDATE()` - прибавления/вычитание временного интервала к дате и времени
  - datetime — дата и время/дата
  - interval — временной интервал
     SUBDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
- `ADDTIME() и SUBTIME()` - прибавления/вычитание временного значения к дате и времени
  - datetime — дата и время/время
  - time — временное значение
    ADDTIME('2023-10-20 21:00:00', '02:00:00'),
- `DATEDIFF()` - используется для вычисления разницы в днях между двумя значениями даты и времени
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
- `TIMEDIFF()` - вычисления разницы во времени
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
- `TIMESTAMPDIFF()` - вычисления разницы между двумя значениями даты и времени в определенных единицах измерения
  - unit — единица измерения, в которой требуется получить разницу
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
      ```TIMESTAMPDIFF(HOUR, '2023-10-20 07:00:00', '2023-10-20 12:00:00')```
- `TIMESTAMP()` - объединения даты и временного значения
  - date — дата
  - time — временное значение
      ```TIMESTAMP('2023-10-20', '08:00')```
    
| Спецификатор |	Описание |
| ---- | ---- |
| %M |	Полное название месяца (January..December) |
| %b |	Сокращенное название месяца (Jan..Dec) |
| %W |	Полное название дня недели (Sunday..Saturday) |
| %a |	Сокращенное название дня недели (Sun..Sat) |
| %Y |	Год (0000..9999) |
| %m |	Номер месяца (00..12) |
| %d |	День месяца (00..31) |
| %w |	Номер дня недели (0..6) |
| %H |	Часы (00..23) |
| %i |	Минуты (00..59) |
| %S |	Секунды (00..59) |
| %f |	Микросекунды (000000..999999) |
| %T |	Время в формате HH:MM:SS |

- `DATE_FORMAT()` - используется для форматирования даты и времени.

В качестве первого аргумента может принимать не только дату и время, но и просто дату. Во втором случае считается, что дата имеет нулевые значения по всем компонентам времени.
  - datetime — дата и время
  - format — строка формата
  
  ```SELECT DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y');```

- `TIME_FORMAT()` - используется для форматирования времени.
  - time — временное значение
  - format — строка формата

- `STR_TO_DATE()` - выполнение операции, обратной форматированию.

Если в строке с компонентами представлены только компоненты даты, функция STR_TO_DATE() вернет дату без времени, если только компоненты времени — время без даты.
  - string — строка с компонентами даты и времени
  - format — строка формата

```SELECT STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y');```

- `GET_FORMAT()` - Используется для получения определенной строки формата для даты, времени или даты и времени.
  - type — тип объекта, для которого требуется строка формата (DATE, TIME или DATETIME)
  - format — непосредственно формат (USA, JIS, ISO или EUR)

```
SELECT DATE_FORMAT('2023-10-20', GET_FORMAT(DATE, 'USA')),
TIME_FORMAT('07:30:00', GET_FORMAT(TIME, 'USA'));
```


## Дополнительные функции
- `ISNULL()` - используется для проверки значения на NULL. Она принимает в качестве аргумента произвольное значение и возвращает 1, если переданным значением является NULL, или 0 в противном случае.
- `IF()` - используется для выбора одного из двух значений в зависимости от результата некоторого условного выражения. Функция возвращает значение `value1`, если условное выражение `condition` истинно, или значение `value2` в противном случае.
  - condition — условное выражение
  - value1 — произвольное значение
  - value2 — произвольное значение
    
```SELECT IF(1 > 0, 'bee', 'geek')```
- `COALESCE()` - используется для поиска первого непустого значения. Она принимает переменное количество аргументов и возвращает первый из них, не равный NULL
```SELECT COALESCE(NULL, 2, 3)```

- `IFNULL()` - используется для замены некоторого значения на альтернативное, если исходное значение равняется NULL
  - value — исходное значение
  - alternative_value — альтернативное значение

- `NULLIF()` - Функция возвращает значение NULL, если значения value1 и value2 совпадают, или значение value1 в противном случае.
  - value1 — произвольное значение
  - value2 — произвольное значение
 
- `CONVERT()` - приводит значение value к типу type и возвращает полученный результат
  - `value` — значение, которое необходимо преобразовать
  - `type` — желаемый тип
  
| Тип |	Описание |
| ----- | ----- | 
| DATE |	значение типа DATE |
| DATETIME |	значение типа DATETIME |
| TIME |	значение типа TIME |
| DECIMAL(M, D) |	значение типа DECIMAL |
| CHAR(N) |	значение типа CHAR |
| BINARY |	значение типа BINARY |
| SIGNED |	значение типа BIGINT с учетом знака |
| UNSIGNED |	значение типа BIGINT без учета знака |
| YEAR |	значение типа YEAR |

- `CAST()` - тоже что и `CONVERT()`но она разделяет передаваемые аргументы не запятой, а ключевым словом AS
```SELECT CAST(100.78 AS DECIMAL(4, 1))```


## Условные конструкции
`Case`
- Простая форма
```
CASE <значение>
    WHEN <первое сравниваемое значение> THEN <результат>
    WHEN <второе сравниваемое значение> THEN <результат>
    ...
    WHEN <n-oe сравниваемое значение> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```
- Усложненная форма
```
CASE
    WHEN <первое условие> THEN <результат>
    WHEN <второе условие> THEN <результат>
    ...
    WHEN <n-oe условие> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```

Как функция
```
SELECT title, author,
       UPPER(CASE
                 WHEN price < 5 THEN 'Cheap'
                 WHEN price BETWEEN 5 AND 15 THEN 'Regular'
                 ELSE 'Expensive'
             END) AS rate
FROM Books;
```

 - Примечания
 - Вернет NULL если не подойдет ни одно условие, без ELSE


## Агрегатные функции
Работают по столбцам
- `AVG()` -  используется для вычисления среднего арифметического числовых значений поля
- `COUNT()` -  подсчет количества записей в таблице или количества значений в поле
- `MIN()` и `MAX()` - минимальное и максимальное значение в поле
- `SUM()` - вычисление суммы числовых значений поля
- `GROUP_CONCAT()` - используется для перечисления значений поля через запятую.
  - Сортировка и изменение разделителя
```
SELECT GROUP_CONCAT(trackname ORDER BY trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

Примечание
1. Внутри AVG(), COUNT(), SUM() и GROUP_CONCAT() можно указать `DISTINCT`, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля
```... AVG(DISTINCT <название поля>)```
2. Агрегатным функциям можно передавать и вычисляемые поля
3. Функции AVG() и SUM() возвращают значение 0.0, если применяются к нечисловым полям.
4. Если все значения поля, переданного в качестве аргумента в агрегатную функцию, имеют значение NULL, возвращаемым значением функции также будет значение NULL.
5. Агрегатные функции не могут использоваться в блоке WHERE (можно через подзапросы)


## Группировка данных
Группировка с фильтрацией
```
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
WHERE streams > 40000
GROUP BY artist
HAVING COUNT(*) > 1;
```

Оператор WHERE фильтрует записи до того, как данные будут сгруппированы, а оператор HAVING — после того, как данные были сгруппированы.
Оператор HAVING следует использовать только вместе с оператором GROUP BY, а оператор WHERE— для стандартной фильтрации на уровне записей.

Порялок операторов при запросе
| Оператор | Описание |
| ----- | ----- |
| SELECT | Данные для извлечения |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Порядок выполнения запросов
| Оператор | Описание |
| ----- | ----- |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| SELECT | Данные для извлечения |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Примечания
-  Для оператора GROUP BY все значения NULL трактуются как равные. Таким образом, при группировке по полю, содержащему значения NULL, все такие записи попадут в одну группу.
-  Если группировка записей выполняется по вычисляемому полю, причем этому полю присвоен псевдоним, то в операторе GROUP BY можно воспользоваться этим псевдонимом. (и при ORDER BY тоже)
-   если в запросе, использующем DISTINCT, необходимо осуществить сортировку, то сделать это можно только по тем полям, которые указаны в операторе SELECT, в противном случае произойдет ошибка.

## Подзапросы
### Некоррелированные подзапросы
Выполняются один раз перед основным запросом
Подзапрос — это запрос, вложенный в другой запрос.

- ALL - истинно для всех значений
```
SELECT title, author, price
FROM Books
WHERE price > ALL (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```
```
select title
from films
where running_time > (select min(running_time) from films)
order by title
```
- ANY (или SOME) - истинно хотя бы одно
```
SELECT title, author, price
FROM Books
WHERE price < ANY (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

#### Примечание
1. Результатом подзапроса является таблица, чтобы ее сипользовать нужно дать ей псевдоним
```
SELECT *
FROM (SELECT title, author, price
      FROM Books) AS BooksCopy;
```
2. Если результатом подзапроса является таблица с единственным значением, то это значение может быть извлечено с помощью оператора SELECT, например, как обычное число.
```
SELECT (SELECT SUM(price)
        FROM Books) AS total;
```

### Коррелированные подзапросы
Выполняются для каждой строки
```
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```
### Подзапросы с несколькими полями
```
SELECT title, critic_score, user_score
FROM Books
WHERE (critic_score, user_score) = (SELECT MIN(critic_score), MIN(user_score)
                                    FROM Books);
```

#### Примечание
1.  Если таблице присвоен псевдоним, то и обращение к полям этой таблицы по полному имени должно происходить только с помощью данного псевдонима.
```
SELECT B.title
FROM Books AS B
WHERE B.author = 'J.R.R. Tolkien';
```

`EXISTS` и `NOT EXISTS` - проверяют, есть ли записи, удовлетворяющие заданному в подзапросе условию. Возвращает TRUE сразу после обнаружения первого подходящего результата в подзапросе


## Джоины
### INNER JOIN - внутреннее соединение - соединении двух таблиц отбираются только те пары записей, для которых выполняется условие соединения.
`FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;`
Обращение к одинаковым полям
```
SELECT Books.id, Authors.id
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```
Чтобы сделать соединение таблицу саму с собой нужно пользоваться псевдонимами
```
SELECT S1.staffer,
       S2.staffer AS manager
FROM Staff AS S1 INNER JOIN Staff AS S2 ON S1.manager_id = S2.id;
```

### Примечания
1. Соединение не является физической таблицей, то есть оно не существует как реальная таблица в базе данных. Соединение создается СУБД по мере необходимости и сохраняется только на время выполнения запроса.
2. Условие соединения таблиц является обыкновенным условием, поэтому может иметь произвольную сложность. Например, оно может быть составлено с использованием ключевых слов AND и OR, а также операторов сравнения, отличных от =.
3. При выполнении внутреннего соединения порядок таблиц не имеет значения. Если мы соединим первую таблицу со второй или вторую с первой, результат будет равнозначным.
4. При использовании оператора INNER JOIN ключевое слово INNER (в переводе на русский "внутренний") является опциональным и может быть опущено.
5. SQL поддерживает дополнительный синтаксис для внутреннего соединения, который имеет следующий вид:
```
SELECT *
FROM Books, Authors WHERE Books.author_id = Authors.id;
```
### Внешнее соединение
При внешнем соединении записям без пары в соответствие ставятся значения NULL
#### Правое - отбираются все пары записей, для которых выполняется условие соединения, а также все оставшиеся записи из правой таблицы, для которых пара не нашлась.
`<первая таблица> RIGHT OUTER JOIN <вторая таблица> ON <условие соединения>`
#### Левое - отбираются все пары записей, для которых выполняется условие соединения, а также все оставшиеся записи из левой таблицы, для которых пара не нашлась.
`<первая таблица> LEFT OUTER JOIN <вторая таблица> ON <условие соединения>`

### Примечания

1. Левое и правое внешние соединения являются взаимозаменяемыми. Например, левое внешнее соединение таблиц Books и Authors равнозначно правому внешнему соединению таблиц Authors и Books.
2. При использовании оператора LEFT OUTER JOIN ключевое слово OUTER (в переводе на русский "внешний") является опциональным и может быть опущено.
3. Виды соединений допустимо комбинировать. Например, при соединении трех таблиц, между первыми двумя таблицами можно выполнить внутреннее соединение, между полученным результатом и третьей таблицей — внешнее.

### Перекрестное соединение -  каждая запись из одной таблицы сопоставляется с каждой записью из другой таблицы. Не требует условия. ( все возможные комбинации соединения строк двух таблиц)
`<первая таблица> CROSS JOIN <вторая таблица>`

### Примечания
1. Перекрестное соединение можно выполнить и без оператора CROSS JOIN, для этого достаточно перечислить соединяемые таблицы через запятую.


## Объединение результатов запросов

```
SELECT id, name, surname
FROM Students

UNION

SELECT id, name, surname
FROM Teachers;```

UNION DISTINCT  - выводит уникальные записи (по умолчанию)
UNION ALL - не будет удаления одинаковых записей
limit и order by нужно указывать в скобках
чтобы применить limit и order by к результату, нужно указать операторы в конце
Кол-во полей должно совпадать
имя полей берется из верхней таблицы
-вместо UNION можно использовать:
  -INTERSECT (пересечение) - используется для получения записей, которые есть в каждом результате запроса.
  - EXCEPT (разность) - используется для получения всех записей первого результата запроса кроме тех, которые встречаются в следующих результатах запросов


## Обновление данных
UPDATE - для изменения значений записей таблицы
```UPDATE Books
SET price = 9.99;
```
### Примечания
1. Оператор UPDATE поддерживает дополнительное ключевое слово IGNORE, которое позволяет не прерывать процесс обновления данных даже при возникновении ошибок. Например, если при обновлении выполняется изменение первичного ключа, которое приводит к появлению дубликатов, такая операция просто игнорируется.
2. Каждое поле таблицы может обладать рядом свойств, которые определяются при создании таблицы. Одним из таких свойств является запрет на хранение значения NULL. Если поле обладает данным свойством и не может содержать значение NULL, то при попытке добавить в него NULL путем изменения любого из имеющихся в поле значений произойдет ошибка.
3. Результатом запроса, обновляющего данные таблицы, не является таблица. Поэтому, если после обновления данных необходимо тут же их получить, можно использовать дополнительный извлекающий запрос.
4. Каждое поле таблицы может иметь значение по умолчанию, которое определяется при создании таблицы. Если поле имеет значение по умолчанию, то при изменении значений этого поля им можно воспользоваться с помощью ключевого слова DEFAULT.
5. При обновлении данных таблицы на основе данных из других таблиц с помощью соединения нельзя использовать сортировку и оператор LIMIT.
6.  При обновлении данных таблицы на основе данных из других таблиц с помощью подзапроса в подзапросе нельзя обращаться к обновляемой таблице.
7.  Если значение поля в какой-либо записи совпадает с обновляемым значением, оно не будет обновлено.


## Удаление данных
### Удаление записей 
`DELETE FROM Books;` - удалить все из таблицы
### Удаление отдельных записей

```
DELETE FROM Books
WHERE title = 'Fight Club';
```
Удаление через соединение таблиц
```
DELETE FROM Books
USING Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.author = 'Chuck Palahniuk';```

### Примечания
1. Можно использовать ORDER BY и LIMIT без ограничений
2. Оператор DELETE поддерживает дополнительное ключевое слово IGNORE
```
DELETE IGNORE FROM Authors
WHERE author = 'Jerome Salinger';
```
3. Для удаления всех записей лучше испольщовать `TRUNCATE Books`, т.к. он работает быстрее
4. При удалении данных из таблиц на основе данных из других таблиц с помощью соединения нельзя использовать сортировку.

## Добавление данных
### Добавление одной записи
```
INSERT INTO Books
VALUES (6, 'Animal Farm', 'George Orwell', NULL);
```
```
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', NULL);
```
### Добавление нескольких записей
```
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', NULL),
       (7, 'Lord of the Flies', 'William Golding', 5.99);
```
### Добавление с помощью ключевого слова SET (можно добавить только одну)
```
INSERT INTO Books
SET id = 6,
    title = 'Animal Farm',
    author = 'George Orwell',
    price = 9.99;
```
### Добавление данных из других таблиц

```
INSERT INTO Books (id, title, author, price)
SELECT id, title, author, price
FROM NewBooks;
```
### Примечания
1. В качестве значений добавляемой записи можно использовать результаты арифметических операций, а также возвращаемые значения различных функций.
2. Значения по умолчанию можно не указывать
3. Оператор INSERT поддерживает дополнительное ключевое слово IGNORE
```
INSERT IGNORE INTO Books (id, title, author, price)
VALUES (1, 'Animal Farm', 'George Orwell', 9.99),
       (6, 'Lord of the Flies', 'William Golding', 5.99);
```
4. В SQL существует оператор REPLACE, который работает как INSERT и UPDATE одновременно: запись добавляется в таблицу, если значение ее первичного ключа уникально. Если же оно совпадает со значением первичного ключа другой записи, то добавляемая запись заменяет эту другую запись.
```
REPLACE INTO Books (id, title, author, price)
VALUES (1, 'Animal Farm', 'George Orwell', 9.99),
       (6, 'Lord of the Flies', 'William Golding', 5.99);
```


## Создание таблиц
```
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

CREATE TABLE IF NOT EXISTS Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  INT
);
```
`surname VARCHAR(20) CHECK (surname != '') NOT NULL,`


### Табличные ограничения
`id     INT NOT NULL` - запрещает полю хранить значение NULL
` id     INT UNIQUE` - запретить полю хранить повторяющиеся значения.
`author VARCHAR(40) DEFAULT 'Unknown'` - определить значение по умолчанию
` id     INT CHECK (id > 0),` - запретить полю хранить значения, не удовлетворяющие заданному условию. 
`CONSTRAINT positive_id CHECK (id > 0)` - изменить название проверки в check
