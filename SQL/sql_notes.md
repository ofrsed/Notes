SQL 
- [Фильтрация-данных](#Фильтрация-данных)
- [Метасимволы](#Метасимволы)
- [Текстовые функции](#Текстовые-функции)
- [Числовые функции](#Числовые-функции)
- [Функции даты и времени](#Функции-даты-и-времени)
- [Дополнительные функции](#Дополнительные-функции)
- [Условные конструкции](#Условные-конструкции)
- [Агрегатные-функции](#Агрегатные-функции)
- [Группировка данных](#Группировка-данных)
- [Подзапросы](#Подзапросы)


```
SELECT DISTINCT artist FROM Songs; - извлекает только уникальные записи
```
```
SELECT trackname FROM Songs LIMIT 3 OFFSET 2; - получить первые 3 записи начиная со 2-й (offset)
limit – количество строк для извлечение,
offset – начальная точка
```
```
SELECT artist, trackname FROM Songs ORDER BY release_date; - сортировка
```
```
SELECT title FROM Songs ORDER BY title ASC; - то же, ASC – по возрастанию (не обязательно)
```
```
SELECT id, artist, trackname FROM Songs ORDER BY artist, id DESC; - сортировка в порядке убывания
DESCENDING – убывание,
ASCENDING - возрастание
```

## Фильтрация данных 
```SELECT * FROM Songs WHERE artist = 'The Sounds' ORDER BY streams;```
| Оператор | Проверка |
| --- | --- |
| `=` | Равенство |
| `<=>` | Эквивалентность |
| `!= или <>` | Неравенство |
| `<` | Меньше |
| `<=` | Меньше или равно |
| `>` | Больше |
| `>=` | Больше или равно |
| `BETWEEN` | Вхождение в диапазон |
| `IS NULL` | Значение NULL |
| `IS NOT NULL` | Не значение NULL |

```
SELECT trackname, artist, streams FROM Songs WHERE streams BETWEEN 50000 AND 100000;
```

```
SELECT place, trackname, artist 
FROM Songs 
WHERE place <= 4 
ORDER BY place 
LIMIT 2;
```
Оператор
IN , NOT IN \ NOT \ AND \ OR

## Метасимволы
```
SELECT trackname, artist FROM Songs WHERE artist LIKE 'The%';
SELECT trackname, artist FROM Songs WHERE trackname LIKE '___ %'; - любой символ
```
Like - не учитывает регистр, чтобы учитывал - WHERE trackname LIKE CAST('%You%' AS BINARY);
или BINARY(trackname) == LOWER(trackname) 

## Текстовые функции
Сравненеие строк просиходи без учета регистра
- `CHAR_LENGTH()` - кол-во символов
- `LOWER() \ UPPER()` - нижний \ верхний регистр
- `LTRIM() \ RTRIM()` -  отсечения ведущих пробелов
- `REVERSE()` - реверс
- `REPEAT()` повторяет строку заданное число раз
  -	str — исходная строка
  -	count — количество повторений
- `LPAD() \ RPAD()` дополняет строку справа другой строкой до заданной длины
  -	str — исходная строка
  -	len — желаемая длина строки
  -	padstr — дополняющая строка
- `LEFT() \ RIGHT()` - извлечения определенного количества символов из начала \ конца строки
  - str — исходная строка
  - count — количество извлекаемых символов
- `LOCATE()` - используется для определения местоположения подстроки в строке. Функция выполняет поиск подстроки substr в строке str, начиная с позиции start, и возвращает позицию ее первого вхождения. (без учета регистра и с 1, а не с 0. Если ничего нет - вернет 0)
  - substr — искомая подстрока
  - str — исходная строка
  - start — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)
- `REPLACE()` - используется для замены подстроки в строке (если нет подстроки, вернет строку в исходном виде, есть учет регистра)
  - str — исходная строка
  - from_str — заменяемая подстрока
  - to_str — заменяющая подстрока
- `SUBSTRING()` используется для извлечения подстроки из строки (с уч. регистра). Она принимает три аргумента в следующем порядке:
  - str — исходная строка
  - start — позиция первого извлекаемого символа
  - len — длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца)
- `SUBSTRING_INDEX()` используется для извлечения подстроки из строки с помощью разделителя. Она принимает три аргумента в следующем порядке:
  - str — исходная строка
  - delimiter — разделитель
  - count — количество появлений разделителя
- `TRIM` -  удаления всех вхождений подстроки из начала и/или конца строки
```
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>)
  Ключевые слова LEADING, TRAILING и BOTH определяют, откуда будет происходить удаление подстроки:
  - LEADING — из начала строки
  - TRAILING  — из конца строки
  - BOTH — из начала и конца строки
```

## Числовые функции
- `Операторы DIV` - целочисленное деление (прим. 11 MOD 2)
- `Оператор MOD` - деление с остатком (прим. SELECT 11 MOD 3, 11 % 3,  MOD(11, 3); 
- `ABS()` - модуль числа
- `ROUND()` - округление числа
  - num — число
  - decimals — количество знаков после запятой
- `FLOOR()` - округление в меньшую
- `CEILING()` - округление в большую
- `POW()` -возведение числа в степень 
  - num — число
  - degree — показатель степени
- `SQRT()` - вычисление квадратного корня
- `RAND()` - генерации случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне [0, 1)
- `DEGREES() и RADIANS()` - перевод значения из радиан в градусы\из градусов в радианы
- `PI(), COS(), SIN() и TAN()` -  получения числа пи (6 знаков)\вычисление синуса, косинуса и тангенса соответственно (принимают в радианах)
   `LEAST() и GREATEST()` -  поиск минимального\максимального значения (принимает переменное кол-во не меньше двух)
- `CONV()` - перевод числа из одной системы счисления в другую
  - num — число
  - from_base — система счисления, в которой представлено число
  - to_base — система счисления, в которую нужно перевести число
- `FORMAT()` - для округления и форматирования числа, форматирует его путем разбиения на разряды
  - num — число
  - decimals — количество знаков после запятой

## Функции даты и времени
Временные интервалы
```
INTERVAL 1 YEAR
INTERVAL '10-2' YEAR_MONTH
```

Поддерживаемые единицы измерения - MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR

Составные:
|  |  |
| --- | --- |
| SECOND_MICROSECOND	| секунды.микросекунды | 
| MINUTE_MICROSECOND	| минуты:секунды.микросекунды | 
| MINUTE_SECOND	| минуты:секунды | 
| HOUR_MICROSECOND	| часы:минуты:секунды.микросекунды | 
| HOUR_SECOND	| часы:минуты:секунды | 
| HOUR_MINUTE	| часы:минуты | 
| DAY_MICROSECOND	| дни часы:минуты:секунды.микросекунды | 
| DAY_SECOND	| дни часы:минуты:секунды | 
| DAY_MINUTE	| дни часы:минуты | 
| DAY_HOUR	| дни часы | 
| YEAR_MONTH	| годы-месяцы | 

- `NOW(), CURDATE() и CURTIME()` - получения текущей даты и времени / дату / время
- `UTC_TIMESTAMP(), UTC_DATE() и UTC_TIME()` - получения текущей даты и времени в нулевом часовом поясе / дату / время
- `MAKEDATE()` - используется для создания даты
  - year — год
  - day — номер дня в году
- `MAKETIME()` - используется для создания временного значения
  - hours — часы
  - minutes — минуты
  - seconds — секунды
- `TIME_TO_SEC() и SEC_TO_TIME()` - преобразования временного значения в секунды / секунд во временное значение
- `TO_DAYS() и TO_SECONDS()` - преобразования даты в количество дней /  преобразует дату в количество секунд (от 0000-00-00 00:00:00)
- `LAST_DAY()` - используется для замены дня на последний день месяца

- `DATE() и TIME()` используется для получения даты\времени из даты и времени
- `HOUR(), MINUTE(), SECOND() и MICROSECOND()` - принимает аргументом временное значение, используется для определения количества часов во времени
- `YEAR(), MONTH() и DAY()` - используется для извлечения значения года\месяца\дня из даты.
- `DAYOFYEAR()` - используется для вычисления номера дня в году (от 1 до 366) на основе даты.
- `WEEK()` - используется для вычисления номера недели в году на основе даты. 
- `WEEKDAY()` - используется для вычисления номера дня недели (от 0 до 6) на основе даты.
- `QUARTER()` -  используется для вычисления номера квартала (от 1 до 4) на основе даты. 
- `DAYNAME()` - используется для вычисления названия дня недели на основе даты. 
- `MONTHNAME()` - используется для определения названия месяца на основе даты. 

`SET lc_time_names` = 'ru_RU'; - установить локализацию. Определяет как будет выводиться название дней недели и месяцев

- `ADDDATE() и SUBDATE()` - прибавления/вычитание временного интервала к дате и времени
  - datetime — дата и время/дата
  - interval — временной интервал
     SUBDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
- `ADDTIME() и SUBTIME()` - прибавления/вычитание временного значения к дате и времени
  - datetime — дата и время/время
  - time — временное значение
    ADDTIME('2023-10-20 21:00:00', '02:00:00'),
- `DATEDIFF()` - используется для вычисления разницы в днях между двумя значениями даты и времени
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
- `TIMEDIFF()` - вычисления разницы во времени
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
- `TIMESTAMPDIFF()` - вычисления разницы между двумя значениями даты и времени в определенных единицах измерения
  - unit — единица измерения, в которой требуется получить разницу
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
      ```TIMESTAMPDIFF(HOUR, '2023-10-20 07:00:00', '2023-10-20 12:00:00')```
- `TIMESTAMP()` - объединения даты и временного значения
  - date — дата
  - time — временное значение
      ```TIMESTAMP('2023-10-20', '08:00')```
    
| Спецификатор |	Описание |
| ---- | ---- |
| %M |	Полное название месяца (January..December) |
| %b |	Сокращенное название месяца (Jan..Dec) |
| %W |	Полное название дня недели (Sunday..Saturday) |
| %a |	Сокращенное название дня недели (Sun..Sat) |
| %Y |	Год (0000..9999) |
| %m |	Номер месяца (00..12) |
| %d |	День месяца (00..31) |
| %w |	Номер дня недели (0..6) |
| %H |	Часы (00..23) |
| %i |	Минуты (00..59) |
| %S |	Секунды (00..59) |
| %f |	Микросекунды (000000..999999) |
| %T |	Время в формате HH:MM:SS |

- `DATE_FORMAT()` - используется для форматирования даты и времени.

В качестве первого аргумента может принимать не только дату и время, но и просто дату. Во втором случае считается, что дата имеет нулевые значения по всем компонентам времени.
  - datetime — дата и время
  - format — строка формата
  
  ```SELECT DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y');```

- `TIME_FORMAT()` - используется для форматирования времени.
  - time — временное значение
  - format — строка формата

- `STR_TO_DATE()` - выполнение операции, обратной форматированию.

Если в строке с компонентами представлены только компоненты даты, функция STR_TO_DATE() вернет дату без времени, если только компоненты времени — время без даты.
  - string — строка с компонентами даты и времени
  - format — строка формата

```SELECT STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y');```

- `GET_FORMAT()` - Используется для получения определенной строки формата для даты, времени или даты и времени.
  - type — тип объекта, для которого требуется строка формата (DATE, TIME или DATETIME)
  - format — непосредственно формат (USA, JIS, ISO или EUR)

```
SELECT DATE_FORMAT('2023-10-20', GET_FORMAT(DATE, 'USA')),
TIME_FORMAT('07:30:00', GET_FORMAT(TIME, 'USA'));
```


## Дополнительные функции
- `ISNULL()` - используется для проверки значения на NULL. Она принимает в качестве аргумента произвольное значение и возвращает 1, если переданным значением является NULL, или 0 в противном случае.
- `IF()` - используется для выбора одного из двух значений в зависимости от результата некоторого условного выражения. Функция возвращает значение `value1`, если условное выражение `condition` истинно, или значение `value2` в противном случае.
  - condition — условное выражение
  - value1 — произвольное значение
  - value2 — произвольное значение
    
```SELECT IF(1 > 0, 'bee', 'geek')```
- `COALESCE()` - используется для поиска первого непустого значения. Она принимает переменное количество аргументов и возвращает первый из них, не равный NULL
```SELECT COALESCE(NULL, 2, 3)```

- `IFNULL()` - используется для замены некоторого значения на альтернативное, если исходное значение равняется NULL
  - value — исходное значение
  - alternative_value — альтернативное значение

- `NULLIF()` - Функция возвращает значение NULL, если значения value1 и value2 совпадают, или значение value1 в противном случае.
  - value1 — произвольное значение
  - value2 — произвольное значение
 
- `CONVERT()` - приводит значение value к типу type и возвращает полученный результат
  - `value` — значение, которое необходимо преобразовать
  - `type` — желаемый тип
  
| Тип |	Описание |
| ----- | ----- | 
| DATE |	значение типа DATE |
| DATETIME |	значение типа DATETIME |
| TIME |	значение типа TIME |
| DECIMAL(M, D) |	значение типа DECIMAL |
| CHAR(N) |	значение типа CHAR |
| BINARY |	значение типа BINARY |
| SIGNED |	значение типа BIGINT с учетом знака |
| UNSIGNED |	значение типа BIGINT без учета знака |
| YEAR |	значение типа YEAR |

- `CAST()` - тоже что и `CONVERT()`но она разделяет передаваемые аргументы не запятой, а ключевым словом AS
```SELECT CAST(100.78 AS DECIMAL(4, 1))```


## Условные конструкции
`Case`
- Простая форма
```
CASE <значение>
    WHEN <первое сравниваемое значение> THEN <результат>
    WHEN <второе сравниваемое значение> THEN <результат>
    ...
    WHEN <n-oe сравниваемое значение> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```
- Усложненная форма
```
CASE
    WHEN <первое условие> THEN <результат>
    WHEN <второе условие> THEN <результат>
    ...
    WHEN <n-oe условие> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```

Как функция
```
SELECT title, author,
       UPPER(CASE
                 WHEN price < 5 THEN 'Cheap'
                 WHEN price BETWEEN 5 AND 15 THEN 'Regular'
                 ELSE 'Expensive'
             END) AS rate
FROM Books;
```

 - Примечания
 - Вернет NULL если не подойдет ни одно условие, без ELSE


## Агрегатные функции
Работают по столбцам
- `AVG()` -  используется для вычисления среднего арифметического числовых значений поля
- `COUNT()` -  подсчет количества записей в таблице или количества значений в поле
- `MIN()` и `MAX()` - минимальное и максимальное значение в поле
- `SUM()` - вычисление суммы числовых значений поля
- `GROUP_CONCAT()` - используется для перечисления значений поля через запятую.
  - Сортировка и изменение разделителя
```
SELECT GROUP_CONCAT(trackname ORDER BY trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

Примечание
1. Внутри AVG(), COUNT(), SUM() и GROUP_CONCAT() можно указать `DISTINCT`, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля
```... AVG(DISTINCT <название поля>)```
2. Агрегатным функциям можно передавать и вычисляемые поля
3. Функции AVG() и SUM() возвращают значение 0.0, если применяются к нечисловым полям.
4. Если все значения поля, переданного в качестве аргумента в агрегатную функцию, имеют значение NULL, возвращаемым значением функции также будет значение NULL.
5. Агрегатные функции не могут использоваться в блоке WHERE (можно через подзапросы)


## Группировка данных
Группировка с фильтрацией
```
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
WHERE streams > 40000
GROUP BY artist
HAVING COUNT(*) > 1;
```

Оператор WHERE фильтрует записи до того, как данные будут сгруппированы, а оператор HAVING — после того, как данные были сгруппированы.
Оператор HAVING следует использовать только вместе с оператором GROUP BY, а оператор WHERE— для стандартной фильтрации на уровне записей.

Порялок операторов при запросе
| Оператор | Описание |
| ----- | ----- |
| SELECT | Данные для извлечения |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Порядок выполнения запросов
| Оператор | Описание |
| ----- | ----- |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| SELECT | Данные для извлечения |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Примечания
-  Для оператора GROUP BY все значения NULL трактуются как равные. Таким образом, при группировке по полю, содержащему значения NULL, все такие записи попадут в одну группу.
-  Если группировка записей выполняется по вычисляемому полю, причем этому полю присвоен псевдоним, то в операторе GROUP BY можно воспользоваться этим псевдонимом. (и при ORDER BY тоже)
-   если в запросе, использующем DISTINCT, необходимо осуществить сортировку, то сделать это можно только по тем полям, которые указаны в операторе SELECT, в противном случае произойдет ошибка.

## Подзапросы
### Некоррелированные подзапросы
Выполняются один раз перед основным запросом
Подзапрос — это запрос, вложенный в другой запрос.

- ALL - истинно для всех значений
```
SELECT title, author, price
FROM Books
WHERE price > ALL (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```
```
select title
from films
where running_time > (select min(running_time) from films)
order by title
```
- ANY (или SOME) - истинно хотя бы одно
```
SELECT title, author, price
FROM Books
WHERE price < ANY (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

#### Примечание
1. Результатом подзапроса является таблица, чтобы ее сипользовать нужно дать ей псевдоним
```
SELECT *
FROM (SELECT title, author, price
      FROM Books) AS BooksCopy;
```
2. Если результатом подзапроса является таблица с единственным значением, то это значение может быть извлечено с помощью оператора SELECT, например, как обычное число.
```
SELECT (SELECT SUM(price)
        FROM Books) AS total;
```

### Коррелированные подзапросы
Выполняются для каждой строки
```
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```
### Подзапросы с несколькими полями
```
SELECT title, critic_score, user_score
FROM Books
WHERE (critic_score, user_score) = (SELECT MIN(critic_score), MIN(user_score)
                                    FROM Books);
```

#### Примечание
1.  Если таблице присвоен псевдоним, то и обращение к полям этой таблицы по полному имени должно происходить только с помощью данного псевдонима.
```
SELECT B.title
FROM Books AS B
WHERE B.author = 'J.R.R. Tolkien';
```
