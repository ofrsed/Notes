SQL 
- __Встроенные функции__
  - [Фильтрация-данных](#Фильтрация-данных)
  - [Метасимволы](#Метасимволы)
  - [Текстовые функции](#Текстовые-функции)
  - [Числовые функции](#Числовые-функции)
  - [Функции даты и времени](#Функции-даты-и-времени)
  - [Дополнительные функции](#Дополнительные-функции)
  - [Условные конструкции](#Условные-конструкции)
- Группировка данных
  - [Агрегатные-функции](#Агрегатные-функции)
  - [Группировка данных](#Группировка-данных)
- Подзапросы
  - [Подзапросы](#Подзапросы)
- Создание таблиц
  - [Соединение таблиц](#Джоины)
- Обновление, удаление и добавление данных
  - [Обновление данных](#Обновление-данных)
  - [Удаление данных](#Удаление-данных)
  - [Добавление данных](#Добавление-данных)
- Создание таблиц и работа с ними
  - [Создание таблиц](#Создание-таблиц)
  - [Удаление таблиц](#Удаление)
  - [Переименование таблицы](#Переименование-таблицы)
  - [Обновление таблицы](#Обновление-таблицы)
  - [Триггеры](#Триггеры)
  - [Индексы](#Индексы)
  - [Представления](#Представления)
  - [CTE](#Обобщенные-табличные-выражения)
- Пользовательские функции
  - [Переменные](#Переменные)
  - [Пользовательские функции](#Пользовательские-функции)
  - [IF-ELSEIF-ELSE](#IF-ELSEIF-ELSE)
  - [Цикл WHILE](#Цикл-WHILE)
  - [Хранимые процедуры](#Хранимые-процедуры)
  - [Процедура с выходными параметрами](#Процедура-с-выходными-параметрами)
- [Оконные функции](#Оконные-функции)
  - [Границы окон](#Границы-окон)
  - [Функции смещения](#Функции-смещения)
- Регулярные выражения

Теория

База данных - программа, в которой мы можем хранить данные
__SQL__ – Structured Query Language, язык структурированных запросов.

__СУБД__ или Система Управления Базами Данных – программный комплекс, помогающий создавать базы данных и проводить манипуляции с данными.
Виды моделей:
- Документная модель
- Модель ключ — значение
- Реляционная модель
- Сетевая модель
- Иерархическая модель

Виды БД:
- реляционные (relation - отношения)
- не реляционные

__Миграция__ - перемещаете данные из исходных баз данных в целевые базы данных

__Первичный ключ (primary key)__ - Поле (или несколько полей), значения которого однозначно определяют записи таблицы. значения которого в таблице не повторяются.

__Внешний ключ (foreign key)__ - Внешний ключ служит для установления связи между строками разных таблиц

__Нормализация__ - свод правил и установок, по которым эти базы проектируются.

__DDL__ – Data Definition Language. С помощью операторов этой группы мы работаем со структурой базы: удаляем, изменяем, создаем объекты и так далее.
- CREATE – создание объекта
- ALTER – изменение объекта
- DROP – удаление объекта

__DML__ – Data Manipulation Language. С помощью этой группы операторов мы можем манипулировать данными, т.е. выгружать их, изменять, добавлять новые и так далее. 
- SELECT – выбор данных
- INSERT – добавление данных
- UPDATE – изменение данных
- DELETE – удаление данных

__DCL__ – Data Control Language. Эта группа позволяет контролировать доступ к данным, т.е. управлять правами и разрешениями.
- GRANT – дает разрешения пользователю
- REVOKE – забирает данные ранее разрешения
- DENY– запрещает

TCL – Transaction Control Language. Это набор операторов для управления транзакциями. Транзакция – набор команд, которые выполняются как единый блок.
- BEGIN TRANSACTION – начало транзакции
- COMMIT TRANSACTION – применение транзакции
- ROLLBACK TRANSACTION – откат транзакции
- SAVE TRANSACTION – промежуточное сохранение транзакции

__Партицирование__ , или секционирование, базы данных — разделение данных, хранящихся в базе данных, на части.
- горизонтальное партицирование — таблица данных разбивается на строки;
- вертикальное партицирование — таблица данных разбивается на столбцы;
- функциональное партицирование — данные группируются согласно контексту их использования в системе.

__Масштабирование БД__ - разделение данных на группы и выделение их на отдельные сервера

__Репликация__  — процесс создания дупликатов БД, вместо одного сервера будет два (например master+slave)

__Шардинг__ - разделение (партиционирование) БД на части, и каждую часть на отдельный сервер. Так мы распределяем нагрузку. Каждая маленькая тарлица - это и есть __шард__. Виды:
- Вертикальный - выделение талбицы или группы таблиц на отдельный сервер
- Горизонтальный - разделение одной таблицы на разные сервера

__Транзакция__ - набор операций по работе с БД, объединенных в одну пачку. Архив для запроса к БД

__Команда VACUUM__ - выполняет полную перестройку таблицы и всех ее индексов

__Команда explain__ - выводит план выполнения SQL-запроса, генерируемый планировщиком для заданного оператора

__Индексация__ - 

## Первичные ключи
### Сурогатные - дополнительное служебное поле, значения которого, в отличие от естественного ключа, не образуются на основе каких-либо данных, а генерируются искусственно.
### Естественные - ключ, содержит полезную информацию об описываемых сущностях
Внешний ключ может ссылаться как на первичный ключ другой таблицы, так и той, в которой он находится. Во втором случае внешний ключ называют `рекурсивным`.

## Виды связей
### Один к одному
### Один ко многим
### Многие ко многим. Связь между таблицами устанавливается путем создания промежуточной таблицы

```
SELECT DISTINCT artist FROM Songs; - извлекает только уникальные записи.  высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных операциях PostgreSQL кортежи, удалённые или устаревшие в результате обновления, физически не удаляются из таблицы; они сохраняются в ней, пока не будет выполнена команда VACUUM. Таким образом, периодически необходимо выполнять VACUUM, особенно для часто изменяемых таблиц.
```
```
SELECT trackname FROM Songs LIMIT 3 OFFSET 2; - получить первые 3 записи начиная со 2-й (offset)
limit – количество строк для извлечение,
offset – начальная точка
```
```
SELECT artist, trackname FROM Songs ORDER BY release_date; - сортировка
```
```
SELECT title FROM Songs ORDER BY title ASC; - то же, ASC – по возрастанию (не обязательно)
```
```
SELECT id, artist, trackname FROM Songs ORDER BY artist, id DESC; - сортировка в порядке убывания
DESCENDING – убывание,
ASCENDING - возрастание
```

## Фильтрация данных 
```SELECT * FROM Songs WHERE artist = 'The Sounds' ORDER BY streams;```
| Оператор | Проверка |
| --- | --- |
| `=` | Равенство |
| `<=>` | Эквивалентность |
| `!= или <>` | Неравенство |
| `<` | Меньше |
| `<=` | Меньше или равно |
| `>` | Больше |
| `>=` | Больше или равно |
| `BETWEEN` | Вхождение в диапазон |
| `IS NULL` | Значение NULL |
| `IS NOT NULL` | Не значение NULL |

```
SELECT trackname, artist, streams FROM Songs WHERE streams BETWEEN 50000 AND 100000;
```

```
SELECT place, trackname, artist 
FROM Songs 
WHERE place <= 4 
ORDER BY place 
LIMIT 2;
```
Оператор
IN , NOT IN \ NOT \ AND \ OR

## Метасимволы
```
SELECT trackname, artist FROM Songs WHERE artist LIKE 'The%';
SELECT trackname, artist FROM Songs WHERE trackname LIKE '___ %'; - любой символ
```
Like - не учитывает регистр, чтобы учитывал - WHERE trackname LIKE CAST('%You%' AS BINARY);
или BINARY(trackname) == LOWER(trackname) 

## Текстовые функции
Сравненеие строк просиходи без учета регистра
- `CHAR_LENGTH()` - кол-во символов
- `LOWER() \ UPPER()` - нижний \ верхний регистр
- `LTRIM() \ RTRIM()` -  отсечения ведущих пробелов
- `REVERSE()` - реверс
- `REPEAT()` повторяет строку заданное число раз
  -	str — исходная строка
  -	count — количество повторений
- `LPAD() \ RPAD()` дополняет строку справа другой строкой до заданной длины
  -	str — исходная строка
  -	len — желаемая длина строки
  -	padstr — дополняющая строка
- `LEFT() \ RIGHT()` - извлечения определенного количества символов из начала \ конца строки
  - str — исходная строка
  - count — количество извлекаемых символов
- `LOCATE()` - используется для определения местоположения подстроки в строке. Функция выполняет поиск подстроки substr в строке str, начиная с позиции start, и возвращает позицию ее первого вхождения. (без учета регистра и с 1, а не с 0. Если ничего нет - вернет 0)
  - substr — искомая подстрока
  - str — исходная строка
  - start — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)
- `REPLACE()` - используется для замены подстроки в строке (если нет подстроки, вернет строку в исходном виде, есть учет регистра)
  - str — исходная строка
  - from_str — заменяемая подстрока
  - to_str — заменяющая подстрока
- `SUBSTRING()` используется для извлечения подстроки из строки (с уч. регистра). Она принимает три аргумента в следующем порядке:
  - str — исходная строка
  - start — позиция первого извлекаемого символа
  - len — длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца)
- `SUBSTRING_INDEX()` используется для извлечения подстроки из строки с помощью разделителя. Она принимает три аргумента в следующем порядке:
  - str — исходная строка
  - delimiter — разделитель
  - count — количество появлений разделителя
- `TRIM` -  удаления всех вхождений подстроки из начала и/или конца строки
```
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>)
  Ключевые слова LEADING, TRAILING и BOTH определяют, откуда будет происходить удаление подстроки:
  - LEADING — из начала строки
  - TRAILING  — из конца строки
  - BOTH — из начала и конца строки
```
`select TRIM( LEADING ' ' from product_name)`

## Числовые функции
- `Операторы DIV` - целочисленное деление (прим. 11 MOD 2)
- `Оператор MOD` - деление с остатком (прим. SELECT 11 MOD 3, 11 % 3,  MOD(11, 3); 
- `ABS()` - модуль числа
- `ROUND()` - округление числа
  - num — число
  - decimals — количество знаков после запятой
- `FLOOR()` - округление в меньшую
- `CEILING()` - округление в большую
- `POW()` -возведение числа в степень 
  - num — число
  - degree — показатель степени
- `SQRT()` - вычисление квадратного корня
- `RAND()` - генерации случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне [0, 1)
- `DEGREES() и RADIANS()` - перевод значения из радиан в градусы\из градусов в радианы
- `PI(), COS(), SIN() и TAN()` -  получения числа пи (6 знаков)\вычисление синуса, косинуса и тангенса соответственно (принимают в радианах)
   `LEAST() и GREATEST()` -  поиск минимального\максимального значения (принимает переменное кол-во не меньше двух)
- `CONV()` - перевод числа из одной системы счисления в другую
  - num — число
  - from_base — система счисления, в которой представлено число
  - to_base — система счисления, в которую нужно перевести число
- `FORMAT()` - для округления и форматирования числа, форматирует его путем разбиения на разряды
  - num — число
  - decimals — количество знаков после запятой

## Функции даты и времени
Временные интервалы

`INTERVAL 1 YEAR`
`INTERVAL '10-2' YEAR_MONTH`

Поддерживаемые единицы измерения - MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR

Составные:
|  |  |
| --- | --- |
| SECOND_MICROSECOND	| секунды.микросекунды | 
| MINUTE_MICROSECOND	| минуты:секунды.микросекунды | 
| MINUTE_SECOND	| минуты:секунды | 
| HOUR_MICROSECOND	| часы:минуты:секунды.микросекунды | 
| HOUR_SECOND	| часы:минуты:секунды | 
| HOUR_MINUTE	| часы:минуты | 
| DAY_MICROSECOND	| дни часы:минуты:секунды.микросекунды | 
| DAY_SECOND	| дни часы:минуты:секунды | 
| DAY_MINUTE	| дни часы:минуты | 
| DAY_HOUR	| дни часы | 
| YEAR_MONTH	| годы-месяцы | 

- `NOW(), CURDATE() и CURTIME()` - получения текущей даты и времени / дату / время
- `UTC_TIMESTAMP(), UTC_DATE() и UTC_TIME()` - получения текущей даты и времени в нулевом часовом поясе / дату / время
- `MAKEDATE()` - используется для создания даты
  - year — год
  - day — номер дня в году
- `MAKETIME()` - используется для создания временного значения
  - hours — часы
  - minutes — минуты
  - seconds — секунды
- `TIME_TO_SEC() и SEC_TO_TIME()` - преобразования временного значения в секунды / секунд во временное значение
- `TO_DAYS() и TO_SECONDS()` - преобразования даты в количество дней /  преобразует дату в количество секунд (от 0000-00-00 00:00:00)
- `LAST_DAY()` - используется для замены дня на последний день месяца

- `DATE() и TIME()` используется для получения даты\времени из даты и времени
- `HOUR(), MINUTE(), SECOND() и MICROSECOND()` - принимает аргументом временное значение, используется для определения количества часов во времени
- `YEAR(), MONTH() и DAY()` - используется для извлечения значения года\месяца\дня из даты.
- `DAYOFYEAR()` - используется для вычисления номера дня в году (от 1 до 366) на основе даты.
- `WEEK()` - используется для вычисления номера недели в году на основе даты. 
- `WEEKDAY()` - используется для вычисления номера дня недели (от 0 до 6) на основе даты.
- `QUARTER()` -  используется для вычисления номера квартала (от 1 до 4) на основе даты. 
- `DAYNAME()` - используется для вычисления названия дня недели на основе даты. 
- `MONTHNAME()` - используется для определения названия месяца на основе даты. 

`SET lc_time_names` = 'ru_RU'; - установить локализацию. Определяет как будет выводиться название дней недели и месяцев

- `ADDDATE() и SUBDATE()` - прибавления/вычитание временного интервала к дате и времени
  - datetime — дата и время/дата
  - interval — временной интервал
     SUBDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
- `ADDTIME() и SUBTIME()` - прибавления/вычитание временного значения к дате и времени
  - datetime — дата и время/время
  - time — временное значение
    ADDTIME('2023-10-20 21:00:00', '02:00:00'),
- `DATEDIFF()` - используется для вычисления разницы в днях между двумя значениями даты и времени
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
- `TIMEDIFF()` - вычисления разницы во времени
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
- `TIMESTAMPDIFF()` - вычисления разницы между двумя значениями даты и времени в определенных единицах измерения
  - unit — единица измерения, в которой требуется получить разницу
  - datetime1 — первая дата и время
  - datetime2 — вторая дата и время
      ```TIMESTAMPDIFF(HOUR, '2023-10-20 07:00:00', '2023-10-20 12:00:00')```
- `TIMESTAMP()` - объединения даты и временного значения
  - date — дата
  - time — временное значение
      ```TIMESTAMP('2023-10-20', '08:00')```
    
| Спецификатор |	Описание |
| ---- | ---- |
| %M |	Полное название месяца (January..December) |
| %b |	Сокращенное название месяца (Jan..Dec) |
| %W |	Полное название дня недели (Sunday..Saturday) |
| %a |	Сокращенное название дня недели (Sun..Sat) |
| %Y |	Год (0000..9999) |
| %m |	Номер месяца (00..12) |
| %d |	День месяца (00..31) |
| %w |	Номер дня недели (0..6) |
| %H |	Часы (00..23) |
| %i |	Минуты (00..59) |
| %S |	Секунды (00..59) |
| %f |	Микросекунды (000000..999999) |
| %T |	Время в формате HH:MM:SS |

- `DATE_FORMAT()` - используется для форматирования даты и времени.

В качестве первого аргумента может принимать не только дату и время, но и просто дату. Во втором случае считается, что дата имеет нулевые значения по всем компонентам времени.
  - datetime — дата и время
  - format — строка формата
  
  ```SELECT DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y');```

- `TIME_FORMAT()` - используется для форматирования времени.
  - time — временное значение
  - format — строка формата

- `STR_TO_DATE()` - выполнение операции, обратной форматированию.

Если в строке с компонентами представлены только компоненты даты, функция STR_TO_DATE() вернет дату без времени, если только компоненты времени — время без даты.
  - string — строка с компонентами даты и времени
  - format — строка формата

```SELECT STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y');```

- `GET_FORMAT()` - Используется для получения определенной строки формата для даты, времени или даты и времени.
  - type — тип объекта, для которого требуется строка формата (DATE, TIME или DATETIME)
  - format — непосредственно формат (USA, JIS, ISO или EUR)

```
SELECT DATE_FORMAT('2023-10-20', GET_FORMAT(DATE, 'USA')),
TIME_FORMAT('07:30:00', GET_FORMAT(TIME, 'USA'));
```


## Дополнительные функции
- `ISNULL()` - используется для проверки значения на NULL. Она принимает в качестве аргумента произвольное значение и возвращает 1, если переданным значением является NULL, или 0 в противном случае.
- `IF()` - используется для выбора одного из двух значений в зависимости от результата некоторого условного выражения. Функция возвращает значение `value1`, если условное выражение `condition` истинно, или значение `value2` в противном случае.
  - condition — условное выражение
  - value1 — произвольное значение
  - value2 — произвольное значение
    
```SELECT IF(1 > 0, 'bee', 'geek')```
- `COALESCE()` - используется для поиска первого непустого значения. Она принимает переменное количество аргументов и возвращает первый из них, не равный NULL
```SELECT COALESCE(NULL, 2, 3)```

- `IFNULL()` - используется для замены некоторого значения на альтернативное, если исходное значение равняется NULL
  - value — исходное значение
  - alternative_value — альтернативное значение

- `NULLIF()` - Функция возвращает значение NULL, если значения value1 и value2 совпадают, или значение value1 в противном случае.
  - value1 — произвольное значение
  - value2 — произвольное значение
 
- `CONVERT()` - приводит значение value к типу type и возвращает полученный результат
  - `value` — значение, которое необходимо преобразовать
  - `type` — желаемый тип
  
| Тип |	Описание |
| ----- | ----- | 
| DATE |	значение типа DATE |
| DATETIME |	значение типа DATETIME |
| TIME |	значение типа TIME |
| DECIMAL(M, D) |	значение типа DECIMAL |
| CHAR(N) |	значение типа CHAR |
| BINARY |	значение типа BINARY |
| SIGNED |	значение типа BIGINT с учетом знака |
| UNSIGNED |	значение типа BIGINT без учета знака |
| YEAR |	значение типа YEAR |

- `CAST()` - тоже что и `CONVERT()`но она разделяет передаваемые аргументы не запятой, а ключевым словом AS
```SELECT CAST(100.78 AS DECIMAL(4, 1))```


## Условные конструкции
`Case`
- Простая форма
```
CASE <значение>
    WHEN <первое сравниваемое значение> THEN <результат>
    WHEN <второе сравниваемое значение> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```
- Усложненная форма
```
CASE
    WHEN <первое условие> THEN <результат>
    WHEN <второе условие> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```

Как функция
```
SELECT title, author,
       UPPER(CASE
                 WHEN price < 5 THEN 'Cheap'
                 WHEN price BETWEEN 5 AND 15 THEN 'Regular'
                 ELSE 'Expensive'
             END) AS rate
FROM Books;
```

 - Примечания
 - Вернет NULL если не подойдет ни одно условие, без ELSE


## Агрегатные функции
Работают по столбцам
- `AVG()` -  используется для вычисления среднего арифметического числовых значений поля
- `COUNT()` -  подсчет количества записей в таблице или количества значений в поле
- `MIN()` и `MAX()` - минимальное и максимальное значение в поле
- `SUM()` - вычисление суммы числовых значений поля
- `GROUP_CONCAT()` - используется для перечисления значений поля через запятую.
  - Сортировка и изменение разделителя
```
SELECT GROUP_CONCAT(trackname ORDER BY trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

Примечание
1. Внутри `AVG()`, `COUNT()`, `SUM()` и `GROUP_CONCAT()` можно указать `DISTINCT`, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля `... AVG(DISTINCT <название поля>)`
3. Агрегатным функциям можно передавать и вычисляемые поля
4. Функции `AVG()` и `SUM()` возвращают значение 0.0, если применяются к нечисловым полям.
5. Если все значения поля, переданного в качестве аргумента в агрегатную функцию, имеют значение NULL, возвращаемым значением функции также будет значение NULL.
6. Агрегатные функции не могут использоваться в блоке WHERE (можно через подзапросы)


## Группировка данных
Группировка с фильтрацией
```
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
WHERE streams > 40000
GROUP BY artist
HAVING COUNT(*) > 1;
```

Оператор WHERE фильтрует записи до того, как данные будут сгруппированы, а оператор HAVING — после того, как данные были сгруппированы.

Оператор HAVING следует использовать только вместе с оператором GROUP BY, а оператор WHERE— для стандартной фильтрации на уровне записей.

Порялок операторов при запросе
| Оператор | Описание |
| ----- | ----- |
| SELECT | Данные для извлечения |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Порядок выполнения запросов
| Оператор | Описание |
| ----- | ----- |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| ... | Оконные функции |
| SELECT | Данные для извлечения |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Примечания
-  Для оператора GROUP BY все значения NULL трактуются как равные. Таким образом, при группировке по полю, содержащему значения NULL, все такие записи попадут в одну группу.
-  Если группировка записей выполняется по вычисляемому полю, причем этому полю присвоен псевдоним, то в операторе GROUP BY можно воспользоваться этим псевдонимом. (и при ORDER BY тоже)
-   если в запросе, использующем DISTINCT, необходимо осуществить сортировку, то сделать это можно только по тем полям, которые указаны в операторе SELECT, в противном случае произойдет ошибка.

## Подзапросы
### Некоррелированные подзапросы
Выполняются один раз перед основным запросом
Подзапрос — это запрос, вложенный в другой запрос.

- `ALL` - истинно для всех значений
```
SELECT title, author, price
FROM Books
WHERE price > ALL (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```
```
select title
from films
where running_time > (select min(running_time) from films)
order by title
```
- `ANY (или SOME)` - истинно хотя бы одно
```
SELECT title, author, price
FROM Books
WHERE price < ANY (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

#### Примечание
1. Результатом подзапроса является таблица, чтобы ее сипользовать нужно дать ей псевдоним
```
SELECT *
FROM (SELECT title, author, price
      FROM Books) AS BooksCopy;
```
2. Если результатом подзапроса является таблица с единственным значением, то это значение может быть извлечено с помощью оператора SELECT, например, как обычное число.
```
SELECT (SELECT SUM(price)
        FROM Books) AS total;
```

### Коррелированные подзапросы
Выполняются для каждой строки
```
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```
### Подзапросы с несколькими полями
```
SELECT title, critic_score, user_score
FROM Books
WHERE (critic_score, user_score) = (SELECT MIN(critic_score), MIN(user_score)
                                    FROM Books);
```

#### Примечание
1.  Если таблице присвоен псевдоним, то и обращение к полям этой таблицы по полному имени должно происходить только с помощью данного псевдонима.
```
SELECT B.title
FROM Books AS B
WHERE B.author = 'J.R.R. Tolkien';
```

`EXISTS` и `NOT EXISTS` - проверяют, есть ли записи, удовлетворяющие заданному в подзапросе условию. Возвращает TRUE сразу после обнаружения первого подходящего результата в подзапросе


## Джоины
<div id="header" align="center">
  <img src="https://github.com/ofrsed/Notes/blob/main/SQL/joins.png" width="600"/>
</div>
### INNER JOIN 
Внутреннее соединение. Соединении двух таблиц отбираются только те пары записей, для которых выполняется условие соединения.

`FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;`

Обращение к одинаковым полям
```
SELECT Books.id, Authors.id
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```
Чтобы сделать соединение таблицу саму с собой нужно пользоваться псевдонимами
```
SELECT S1.staffer,
       S2.staffer AS manager
FROM Staff AS S1 INNER JOIN Staff AS S2 ON S1.manager_id = S2.id;
```

### Примечания
1. Соединение не является физической таблицей, то есть оно не существует как реальная таблица в базе данных. Соединение создается СУБД по мере необходимости и сохраняется только на время выполнения запроса.
2. Условие соединения таблиц является обыкновенным условием, поэтому может иметь произвольную сложность. Например, оно может быть составлено с использованием ключевых слов AND и OR, а также операторов сравнения, отличных от =.
3. При выполнении внутреннего соединения порядок таблиц не имеет значения. Если мы соединим первую таблицу со второй или вторую с первой, результат будет равнозначным.
4. При использовании оператора INNER JOIN ключевое слово INNER (в переводе на русский "внутренний") является опциональным и может быть опущено.
5. SQL поддерживает дополнительный синтаксис для внутреннего соединения, который имеет следующий вид:
```
SELECT *
FROM Books, Authors WHERE Books.author_id = Authors.id;
```
### Внешнее соединение
При внешнем соединении записям без пары в соответствие ставятся значения NULL
- Правое
Обираются все пары записей, для которых выполняется условие соединения, а также все оставшиеся записи из правой таблицы, для которых пара не нашлась.
`<первая таблица> RIGHT OUTER JOIN <вторая таблица> ON <условие соединения>`
- Левое
Отбираются все пары записей, для которых выполняется условие соединения, а также все оставшиеся записи из левой таблицы, для которых пара не нашлась.
`<первая таблица> LEFT OUTER JOIN <вторая таблица> ON <условие соединения>`

### Примечания

1. Левое и правое внешние соединения являются взаимозаменяемыми. Например, левое внешнее соединение таблиц Books и Authors равнозначно правому внешнему соединению таблиц Authors и Books.
2. При использовании оператора LEFT OUTER JOIN ключевое слово OUTER (в переводе на русский "внешний") является опциональным и может быть опущено.
3. Виды соединений допустимо комбинировать. Например, при соединении трех таблиц, между первыми двумя таблицами можно выполнить внутреннее соединение, между полученным результатом и третьей таблицей — внешнее.
4. Несколько джоинов сразу
```
select *
from Orders as O left join Sellers as S on O.seller_id = S.id
				 left join Customers as C on O.customer_id = C.id
```



### Перекрестное соединение
Каждая запись из одной таблицы сопоставляется с каждой записью из другой таблицы. Не требует условия. ( все возможные комбинации соединения строк двух таблиц)
`<первая таблица> CROSS JOIN <вторая таблица>`

### Примечания
1. Перекрестное соединение можно выполнить и без оператора CROSS JOIN, для этого достаточно перечислить соединяемые таблицы через запятую.


## Объединение результатов запросов

```
SELECT id, name, surname
FROM Students

UNION

SELECT id, name, surname
FROM Teachers;
```

`UNION DISTINCT`  - выводит уникальные записи (по умолчанию)
`UNION ALL` - не будет удаления одинаковых записей

### Примечания
1. `limit` и `order by` нужно указывать в скобках
2. Xтобы применить limit и order by к результату, нужно указать операторы в конце
3. Кол-во полей должно совпадать
4. имя полей берется из верхней таблицы
-Dместо `UNION` можно использовать:
  -`INTERSECT` (пересечение) - используется для получения записей, которые есть в каждом результате запроса.
  -`EXCEPT` (разность) - используется для получения всех записей первого результата запроса кроме тех, которые встречаются в следующих результатах запросов


## Обновление данных
UPDATE
Изменение значений записей таблицы
```
UPDATE Books
SET price = 9.99;
```

### Примечания
1. Оператор UPDATE поддерживает дополнительное ключевое слово IGNORE, которое позволяет не прерывать процесс обновления данных даже при возникновении ошибок. Например, если при обновлении выполняется изменение первичного ключа, которое приводит к появлению дубликатов, такая операция просто игнорируется.
2. Каждое поле таблицы может обладать рядом свойств, которые определяются при создании таблицы. Одним из таких свойств является запрет на хранение значения NULL. Если поле обладает данным свойством и не может содержать значение NULL, то при попытке добавить в него NULL путем изменения любого из имеющихся в поле значений произойдет ошибка.
3. Результатом запроса, обновляющего данные таблицы, не является таблица. Поэтому, если после обновления данных необходимо тут же их получить, можно использовать дополнительный извлекающий запрос.
4. Каждое поле таблицы может иметь значение по умолчанию, которое определяется при создании таблицы. Если поле имеет значение по умолчанию, то при изменении значений этого поля им можно воспользоваться с помощью ключевого слова DEFAULT.
5. При обновлении данных таблицы на основе данных из других таблиц с помощью соединения нельзя использовать сортировку и оператор LIMIT.
6.  При обновлении данных таблицы на основе данных из других таблиц с помощью подзапроса в подзапросе нельзя обращаться к обновляемой таблице.
7.  Если значение поля в какой-либо записи совпадает с обновляемым значением, оно не будет обновлено.


## Удаление данных
- Удаление записей 
`DELETE FROM Books;` - удалить все из таблицы
- Удаление отдельных записей

```
DELETE FROM Books
WHERE title = 'Fight Club';
```

- Удаление через соединение таблиц
```
DELETE FROM Books
USING Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.author = 'Chuck Palahniuk';
```

### Примечания
1. Можно использовать ORDER BY и LIMIT без ограничений
2. Оператор DELETE поддерживает дополнительное ключевое слово IGNORE
```
DELETE IGNORE FROM Authors
WHERE author = 'Jerome Salinger';
```
3. Для удаления всех записей лучше испольщовать `TRUNCATE Books`, т.к. он работает быстрее
4. При удалении данных из таблиц на основе данных из других таблиц с помощью соединения нельзя использовать сортировку.

## Добавление данных
- Добавление одной записи
```
INSERT INTO Books
VALUES (6, 'Animal Farm', 'George Orwell', NULL);
```
```
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', NULL);
```
- Добавление нескольких записей
```
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', NULL),
       (7, 'Lord of the Flies', 'William Golding', 5.99);
```
- Добавление с помощью ключевого слова SET (можно добавить только одну)
```
INSERT INTO Books
SET id = 6,
    title = 'Animal Farm',
    author = 'George Orwell',
    price = 9.99;
```
- Добавление данных из других таблиц

```
INSERT INTO Books (id, title, author, price)
SELECT id, title, author, price
FROM NewBooks;
```
### Примечания
1. В качестве значений добавляемой записи можно использовать результаты арифметических операций, а также возвращаемые значения различных функций.
2. Значения по умолчанию можно не указывать
3. Оператор INSERT поддерживает дополнительное ключевое слово IGNORE

```
INSERT IGNORE INTO Books (id, title, author, price)
VALUES (1, 'Animal Farm', 'George Orwell', 9.99),
       (6, 'Lord of the Flies', 'William Golding', 5.99);
```

4. В SQL существует оператор REPLACE, который работает как INSERT и UPDATE одновременно: запись добавляется в таблицу, если значение ее первичного ключа уникально. Если же оно совпадает со значением первичного ключа другой записи, то добавляемая запись заменяет эту другую запись.
```
REPLACE INTO Books (id, title, author, price)
VALUES (1, 'Animal Farm', 'George Orwell', 9.99),
       (6, 'Lord of the Flies', 'William Golding', 5.99);
```


## Создание таблиц
```
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

CREATE TABLE IF NOT EXISTS Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  INT
);
```
`surname VARCHAR(20) CHECK (surname != '') NOT NULL,`


### Табличные ограничения
- `id INT NOT NULL` - запрещает полю хранить значение NULL
- `id INT UNIQUE` - запретить полю хранить повторяющиеся значения.
- `author VARCHAR(40) DEFAULT 'Unknown'` - определить значение по умолчанию
- `id INT CHECK (id > 0),` - запретить полю хранить значения, не удовлетворяющие заданному условию. 
- `CONSTRAINT positive_id CHECK (id > 0)` - изменить название проверки в check
- `id INT PRIMARY KEY,` то же что и UNIQUE NOT NULL, но нагляднее
- `PRIMARY KEY (title, author)` - Составной первичный ключ, может быть только один
- `id INT PRIMARY KEY AUTO_INCREMENT,` - автоматического заполнения поля рядом натуральных чисел. Теперь id можно не указывать .Может быть только один и у PRIMARY KEY. При удаления записей id не меняется, но чтобы менялись можно использовать счетчик TRUNCATE  `TRUNCATE Books;` - удаление всех строк в таблице
- `id INT,  FOREIGN KEY (author_id) REFERENCES Authors (id)` - Внешний ключ
  -`ON UPDATE` - поведение пи обновлении
  -`ON DELETE` - поведение при удалении
    -`RESTRICT - возниктнт ошибка
    -`CASCADE` -  изменении или удалении данных в родительской таблице аналогичные действия будут автоматически применены и к связанным записям в дочерней таблице.
    -SET NULL - при изменении или удалении данных в родительской таблице связанные записи в дочерней таблице в качестве значения внешнего ключа примут значение NULL

```
FOREIGN KEY (author_id) REFERENCES Authors (id)
  ON UPDATE CASCADE
  ON DELETE CASCADE
  ```

- `DESCRIBE Books;` - получить информацию о полях таблицы

## Удаление
-`DROP TABLE Books;` - удалить таблицу
-`DROP TABLE IF EXISTS Books;` - запрос с проверкой существования таблицы
## Переименование таблицы
- `RENAME TABLE Books TO OldBooks;` - переименование таблицы
## Обновление таблицы
- `ALTER TABLE Books DROP COLUMN author;` - удаление поля
- `ALTER TABLE Books RENAME COLUMN author TO writer;` - переименование поля
- `ALTER TABLE Books ADD COLUMN release_year INT CHECK (release_year > 0);` - добавить поле (в конец по умолчанию)
- `ALTER TABLE Books ADD COLUMN release_year INT CHECK (release_year > 0) FIRST;`- добавить в начало
- `ALTER TABLE Books ADD COLUMN release_year INT CHECK (release_year > 0) AFTER title;` - добавить после поля ...
- `ALTER TABLE Books MODIFY COLUMN title VARCHAR(60) CHECK (title != '');` - обновить(полностью изменить) тип поля
- `ALTER TABLE Books ALTER COLUMN title SET DEFAULT 'Untitled';` - задать полю значение по умолчанию
- `ALTER TABLE Books ALTER COLUMN title DROP DEFAULT;` - удалить значение по умолчанию
- `ALTER TABLE Books ADD PRIMARY KEY (id);` - добавить первичный ключ
- `ALTER TABLE Books DROP PRIMARY KEY;` - удалить первичный ключ

- `ALTER TABLE Books ADD FOREIGN KEY (publisher) REFERENCES Publishers (name);` - добавить внешний ключ
- `ALTER TABLE Books DROP FOREIGN KEY publisher;` - удалить внешний ключ

- `ALTER TABLE Books ADD CHECK (title != '');` - дабавить проверку
- `ALTER TABLE Books ADD CONSTRAINT title_is_not_empty_string CHECK (title != '');` - добавить проверку с именем
- `ALTER TABLE Books DROP CONSTRAINT title_is_not_empty_string;` - удалить проверку

Несколько действий
```
ALTER TABLE Books
ADD COLUMN release_year INT,
ADD COLUMN publisher VARCHAR(40);
```


## Триггеры
Предназначены для автоматического выполнения действий при изменении данных
```
DELIMITER //
CREATE TRIGGER <имя триггера>
<время срабатывания триггера> <операция, которая вызывает триггер>
ON <имя таблицы>
FOR EACH ROW
BEGIN
    <тело триггера>;
END //
DELIMITER ;
```
- Время срабатывания
  - BEFORE - перед
  - AFTER - после
- Операция, которая вызывает триггер
  - INSERT
  - DELETE
  - UPDATE

- Доступ к значениям записи
  - BEFORE INSERT — имеет доступ к значениям добавляемой записи; может изменять значения добавляемой записи
  - AFTER INSERT — имеет доступ к значениям добавленной записи
  - BEFORE UPDATE — имеет доступ к старым и новым значениям обновляемой записи; может изменять новые значения обновляемой записи
  - AFTER UPDATE — имеет доступ к старым и новым значениям обновленной записи
  - BEFORE DELETE — имеет доступ к значениям удаляемой записи
  - AFTER DELETE — имеет доступ к значениям удаленной записи
  ```

NEW - обратиться к новым данным
OLD - обратиться к старым данным

```
  DELIMITER //
CREATE TRIGGER name_and_surname_formatting
BEFORE INSERT
ON Authors
FOR EACH ROW
BEGIN
    SET NEW.name = CONCAT(UPPER(LEFT(NEW.name, 1)), LOWER(SUBSTRING(NEW.name, 2)));
    SET NEW.surname= CONCAT(UPPER(LEFT(NEW.surname, 1)), LOWER(SUBSTRING(NEW.surname, 2)));
END //
DELIMITER ;

INSERT INTO Authors (name, surname) 
VALUES ('LEO', 'TOLSTOY'),
       ('william', 'shakespeare'),
       ('fYODOr', 'dOSTOYEVSKy');
       
SELECT id, name, surname
FROM Authors;
```

## Индексы
Индекс — это структура данных, предназначенная для ускорения поиска и сортировки данных. Индексы позволяют быстро находить нужные записи таблицы на основе значений одного или нескольких полей. Без индексов поиск данных в больших таблицах может быть медленным и ресурсоемким, поскольку подразумевает просмотр всей таблицы от первой записи до последней.

Индексы ускоряют выполнение операции извлечения, однако при этом они могут замедлить операции вставки, обновления и удаления, так как эти операции требуют обновления индексов.


некластеризованные
Некластеризованный индекс хранит лишь ссылки на записи, поэтому сами записи в памяти могут иметь произвольное расположение.
Некластеризованный индекс может быть создан как на основе одного поля, так и нескольких. При этом важно помнить, что чем больше количество полей в индексе, тем больше памяти он занимает.

кластеризованные
имеет каждая таблица, создается автоматически на основе первичного ключа. Если у таблицы нет первичного ключа или другого подходящего поля, которое может быть использовано в качестве первичного, СУБД создаст такое поле сама.
Кластеризованный индекс организует физический порядок хранения записей таблицы. Это означает, что записи, имеющие близкие ключевые значения, также будут близко расположены в памяти.
```
CREATE INDEX idx_release_year
ON Books(release_year);
```

```
​CREATE INDEX idx_author_release_year
ON Books(author, release_year);
```

Удаление индекса
```
DROP INDEX idx_release_year ON Books;
```

Переименование индекса
```
ALTER TABLE Books
RENAME INDEX idx_release_year TO release_year_index;
```

## Представления
Представление — это виртуальная таблица. Содержит запрос, который динамически извлекает данные тогда, когда это необходимо.
```
CREATE VIEW FirstBooks AS  (или CREATE OR REPLACE VIEW FirstBooks AS)
SELECT *
FROM Books
LIMIT 3;

SELECT *
FROM FirstBooks;
```

Изменить представление

```
ALTER VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;
```

Удаление представлений
`DROP VIEW FirstBooks;`

### Примкчания
1. Определить названия полей виртуальной таблицы можно путем указания этих имен в скобках через запятую после названия представления `CREATE VIEW BooksInfo (bookname, writer) AS`
2. Представления могут быть вложенными
3. Представления предназначены для извлечения данных, а не изменени
4.  С помощью представлений можно ограничивать доступ к данным, предоставляя пользователю или приложению права не на таблицу, а на представление.
5.  Должны иметь уникальные имена

## Обобщенные табличные выражения
Обобщенное табличное выражение или CTE (Common Table Expressions) - это временная таблица, существующая в рамках одного запроса. Используется для избежания дублирования запросов

CTE является физической таблицей, которая помещается в оперативную память
```
WITH StephenKingBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Stephen' and Authors.surname = 'King' 
)

SELECT title
FROM StephenKingBooks
WHERE release_year = (SELECT MAX(release_year)
                      FROM StephenKingBooks);
```

### Примечания:
1. Можно определить несколько CTE, разделив их запятыми `WITH StephenKingBooks AS (...), JeromeSalingerBooks AS (...)`. Записывается в память последовательно, поэтому можно обращаться к предыдущему
2. Отличие от представления в том, что это временная таблица, а там объект базы данных
3. Определить названия полей CTE можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имен в скобках через запятую после названия CTE.
```

WITH FirstBooks (bookname, year) AS (
    SELECT title, release_year
    FROM Books
    LIMIT 3
)

SELECT *
FROM FirstBooks;
```
4. Важно помнить, что CTE существует только в рамках того запроса, в котором он определен.

### Рекурсивный CTE
```
WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number                         -- нерекурсивный запрос
    UNION ALL -- или UNION DISTINCT
    SELECT number + 1                          -- рекурсивный  запрос
    FROM NaturalNumbers
    WHERE number < 10
)

SELECT *
FROM NaturalNumbers;
```

### Примечание
1. В рекурсивном запросе рекурсивного CTE не могут использоваться агрегатные функции, а также операторы GROUP BY, ORDER BY и DISTINCT.
2.  По умолчанию рекурсивный запрос в рекурсивном CTE может выполнить не более 1000 итераций. Можно увеличить через `SET @@cte_max_recursion_depth := 10000;`
3.  Тип данных поля number в CTE Numbers является целочисленным, поэтому все добавляемые в него значения будут автоматически приводиться к этому типу путем округления.

```
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT id, name, 1 AS level
    FROM Employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT Employees.id, Employees.name, EmployeeHierarchy.level + 1
    FROM EmployeeHierarchy INNER JOIN Employees ON EmployeeHierarchy.id = Employees.manager_id
)

SELECT *
FROM EmployeeHierarchy;
```

## Переменные
Переменная в программировании — это именованная область памяти, которая хранит определенные данные и позволяет неоднократно к ним обращаться.
### Пользовательские
Определяются программистом `SET @variable := 1;`

```
SET @variable := 1,
    @variabel2 := 2
    @min_price := (SELECT MIN(price)
                   FROM Books);
    
SELECT @variable;
```
Определение переменной в запросе
```

SELECT MIN(price) INTO @min_price
FROM Books;

SELECT @min_price;
```

```
SELECT MIN(price), MAX(price) INTO @min_price, @max_price
FROM Books;

SELECT @min_price, @max_price;
```
### Примечания
1. Нечувствительны к регистру
2.  может включать буквенно-цифровые символы, точку (.), нижнее подчеркивание (_) и знак доллара ($). Максимальное количество символов в имени переменной равняется 64.
3. Значением пользовательской переменной может быть результат некоторого вычисления или возвращаемое значение функции.
4. Всегда должна возвращать одиночное значение
5. Попытка определить пользовательскую переменную, имя которой совпадает с именем существующей переменной, приведет к переопределению переменной, а не к ошибке.
6. Пользовательская переменная, определенная одним пользователем, не видна другим пользователям. Другими словами, пользовательская переменная является специфичной для сессии.
7. Значением пользовательской переменной может быть значение из ограниченного набора типов данных: целое число, число с плавающей точкой, число с фиксированной точкой, строка или значение NULL. Если переменной присваивается значение иного типа, например, дата, то оно автоматически будет преобразовано в строковое.
8. При определении пользовательской переменной с помощью ключевого слова SET допустимо использовать оператор =. `SET @variable = 1;`

### Системные
Существует для хранения системной информации и настройки параметров
`@@version` - получить версию СУБД

#### Сессионные
Существуют только сессию. По умолсанию обращение происходит к сессионным переменным (если без `global.`).

Указать, что обращение происходит именно к сессионной переменной, можно не только опустив префикс `global.`, но и добавив префикс `session..`
`SET @@sort_buffer_size := 262146;`
`SET @@session.sort_buffer_size := 262146;`
#### Глобальные
Указывается администратором призапуске БД, и неизменяемы
`SET @@global.sort_buffer_size := 262146;` - установить глобально

## Пользовательские функции

Пользовательские функции - Функции, которые не являются встроенными, а определены пользователем
Бывают детерминированные (при одних и тех же входных данных возвращают один и тот же результат), недетерминированные (при одних и тех же данных возвращают разный результат) и скалярные (результатом работы которой является единственное значение)

### Создание пользовательских функций
Шаблон
```
DELIMITER //
CREATE FUNCTION <имя функции>(<имя 1 параметра и его тип>, <имя 2 параметра и его тип>, ...)
RETURNS <тип возвращаемого значения>
<вид функции: детерминированная или недетерминированная>
BEGIN
    <тело функции>;
    RETURN <возвращаемое значение>;
END //
DELIMITER ;
```

```
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN IF(number MOD 2 = 0, 1, 0);
END //
DELIMITER ;

SELECT IS_EVEN(10),
       IS_EVEN(15);
```

```
DELIMITER //
CREATE FUNCTION CAPITALIZE(string TEXT)
RETURNS TEXT
DETERMINISTIC
BEGIN
    RETURN CONCAT(UPPER(LEFT(string, 1)), LOWER(SUBSTRING(string, 2)));
END //
DELIMITER ;

SELECT CAPITALIZE('beegeek'),
       CAPITALIZE('BeeGeek'),
       CAPITALIZE('BEEGEEK');
```

```

DELIMITER //
CREATE FUNCTION STUDENTS_WITH_GRADE(score INT)
RETURNS INT
NOT DETERMINISTIC
READS SQL DATA  -- работает с БД
BEGIN
    RETURN (SELECT COUNT(*)
            FROM Math
            WHERE grade = score);
END //
DELIMITER ;

SELECT STUDENTS_WITH_GRADE(4),
       STUDENTS_WITH_GRADE(5);
```

Определение локальных переменных в функции (локальные переменные доступны только в этой функции)
```
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);
    RETURN CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```

#### Примечания
1. Функции, создаваемые с помощью оператора CREATE FUNCTION, являются скалярными, то есть всегда возвращают единственное значение.
2. При определении локальной переменной для нее можно указать значение по умолчанию, которое переменная примет сразу же после определения. `DECLARE variable INT DEFAULT 0`
3. Можно добавить комментарии
```
DELIMITER //
CREATE FUNCTION VECTOR_ABS(x INT, y INT)
RETURNS FLOAT
DETERMINISTIC
COMMENT 'Функция возвращает модуль двумерного вектора'
BEGIN
    RETURN SQRT(POW(x, 2) + POW(y, 2));
END //
DELIMITER ;

SELECT VECTOR_ABS(3, 4),
       VECTOR_ABS(6, 8);
```
4. Пользовательская функция может быть удалена после создания. `DROP FUNCTION IS_EVEN;`
5. Пользовательские функции нечувствительны к регистру
6. Если используется пара ключевых слов NOT DETERMINISTIC, обязательно нужно пояснить, почему функция является недетерминированной. Если функция работает с информацией, хранящейся в таблицах базы данных, после NOT DETERMINISTIC с новой строки необходимо добавить READS SQL DATA. Если функция не обращается к таблицам базы данных, но при этом выполняет вычисления со случайным результатом, после NOT DETERMINISTIC с новой строки необходимо добавить NO SQL.

## IF-ELSEIF-ELSE

```
IF <первое проверяемое условие> THEN
    <одна или несколько операций>;
ELSEIF <второе проверяемое условие> THEN
    <одна или несколько операций>;
ELSEIF <третье проверяемое условие> THEN
    <одна или несколько операций>;
...
ELSEIF <n-ое проверяемое условие> THEN
    <одна или несколько операций>;
ELSE <одна или несколько операций>;
END IF;
```

```

DELIMITER //
CREATE FUNCTION ANALYSE(number INT)
RETURNS TEXT
DETERMINISTIC
BEGIN
    IF number > 0 THEN
        RETURN 'Positive';
    ELSEIF number < 0 THEN
        RETURN 'Negative';
    ELSE
        RETURN 'Zero';
    END IF;
END //
DELIMITER ;

SELECT ANALYSE(5),
       ANALYSE(-10),
       ANALYSE(0);
```

## Цикл WHILE
```

DELIMITER //
CREATE FUNCTION CALCULATE_HOURS(minutes INT)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE result INT DEFAULT 0;                -- конечное количество часов
   
    WHILE minutes >= 60 DO                       -- проверяем, что количество минут больше или равно 60
        SET result := result + 1;                -- увеличиваем количество часов на единицу
        SET minutes := minutes - 60;             -- уменьшаем количество минут на 60 минут (1 час)
    END WHILE;
   
    RETURN result;
END //
DELIMITER ;

SELECT CALCULATE_HOURS(30),
       CALCULATE_HOURS(60),
       CALCULATE_HOURS(95),
       CALCULATE_HOURS(125);
```

### Примечания
1. Условную конструкцию IF-ELSEIF-ELSE и цикл WHILE нельзя использовать вне функций.
2. SQL ориентирован на выполнение запросов, а не на вычисления, поэтому, несмотря на то что язык позволяет реализовывать сложные конструкции с помощью циклов и условий, рекомендуется избегать их применения ради поддержания оптимальной производительности.
3. ELSEIF и ELSE необязательные блоки


## Хранимые процедуры
То же что и функции, но не имеют возвращаемого значения
```

DELIMITER //
CREATE PROCEDURE HIGH_GRADE_STUDENTS()
BEGIN
    SELECT *
    FROM Math
    WHERE grade >= 4;
END //
DELIMITER ;

CALL HIGH_GRADE_STUDENTS;
```

### Примечания 
1. При создании хранимой процедуры ее можно определить как детерминированную или недетерминированную, однако, в отличие от пользовательских функций, делать это необязательно.
2. Хранимую процедуру можно дополнить строкой документации. Для этого перед блоком BEGIN END необходимо указать ключевое слово COMMENT, а затем предоставить строку, содержащую краткое описание поведения процедуры.
3. Хранимая процедура может быть удалена после создания. `DROP PROCEDURE HIGH_GRADE_STUDENTS;`
4. Хранимые процедуры нечувствительны к регистру,


### Процедура с входными параметрами
```

DELIMITER //
CREATE PROCEDURE STUDENTS_WITH_GRADE_BETWEEN(IN min_score INT, IN max_score INT)
BEGIN
    SELECT id, name, surname, grade
    FROM Math
    WHERE grade BETWEEN min_score AND max_score;
END //
DELIMITER ;

CALL STUDENTS_WITH_GRADE_BETWEEN(2, 4);
```

## Процедура с выходными параметрами
```

DELIMITER //
CREATE PROCEDURE MAX_GRADE(OUT score INT)
BEGIN
    SET score := (SELECT MAX(grade)
                  FROM Math);
END //
DELIMITER ;

SET @max_grade = NULL;

CALL MAX_GRADE(@max_grade);

SELECT @max_grade;
```

```

DELIMITER //
CREATE PROCEDURE MIN_MAX_GRADES(OUT min_score INT, OUT max_score INT)
BEGIN
    SET min_score := (SELECT MIN(grade)
                      FROM Math),
        max_score := (SELECT MAX(grade)
                      FROM Math);
END //
DELIMITER ;

SET @min_grade := NULL,
    @max_grade := NULL;

CALL MIN_MAX_GRADES(@min_grade, @max_grade);

SELECT @min_grade, @max_grade;
```

### Примечания
1. Хранимые процедуры поддерживают дополнительный вид параметров, определяемый с помощью ключевого слова INOUT. Параметр, перед именем которого указано такое ключевое слово, ведет себя как входной и выходной одновременно.
2. Пользовательскую переменную, которая будет передана в качестве аргумента выходному параметру, можно не создавать явно. В таком случае переменная будет создана автоматически.

```

DELIMITER //
CREATE PROCEDURE MAX_GRADE(OUT score INT)
BEGIN
    SELECT MAX(grade) INTO score
    FROM Math;
END //
DELIMITER ;

CALL MAX_GRADE(@max_grade);

SELECT @max_grade;
```
3. Параметры процедуры по умолчанию являются входными, поэтому ключевое слово IN указывать необязательно.
4. Начальное значение выходного параметра OUT всегда равно NULL независимо от того, что хранилось в переменной до этого.


## Оконные функции

Результирующий набор - таблица, сформированная после JOIN, FROM, WHERE GROUP BY и HAVING
Результат запроса - формируется после SELECT, AS, ORDER BY и LIMIT

Оконная функция — это функция, которая выполняет вычисления на основе определенного набора записей и возвращает одиночное значение. Набор записей, с которым работает оконная функция, называют окном. По умолчанию содержимое окна полностью совпадает с результирующим набором запроса, в рамках которого определено окно.

`WINDOW <название окна> AS (<спецификация окна>)`

Спецификация окна, заключаемая в круглые скобки, может включать три базовых элемента: секционирование (разбиение на секции), упорядочивание и определение границ окна.

Порядок выполнения запросов
| Оператор | Описание |
| ----- | ----- |
| FROM | Таблица для извлечения данных |
| WHERE | Фильтрация на уровне записей |
| GROUP BY | Создание групп |
| HAVING | Фильтрация на уровне групп |
| ... | Оконные функции |
| SELECT | Данные для извлечения |
| ORDER BY | Порядок сортировки результатов |
| LIMIT | Ограничение количества записей |

Оконные функции обычно подразделяют на три основные группы: ранжирующие функции, агрегатные функции и функции смещения.

```
SELECT full_name,
       ROW_NUMBER() OVER all_rows AS row_num
FROM Employees
WINDOW all_rows AS ();
```

Секционирование - две записи попадают в одну секцию, если их значения по выбранному полю (или нескольким) совпадают. Функция будет работать не со всем окнос, а с определенной секцией. Секционирование выполняется с помощью оператора `PARTITION BY`

```
SELECT full_name, department, salary,
       ROW_NUMBER() OVER salary_desc_part_by_department AS row_num
FROM Employees
WINDOW salary_desc_part_by_department AS (PARTITION BY department ORDER BY salary DESC);
```

ORDER BY тут работает для каждой секции

`ROW_NUMBER()` - номер строки
`DENSE_RANK()` - вычисляет ранг записи в рамках окна. Значение поля (или нескольких полей), по которому было выполнено упорядочивание, будет использоваться для вычисления ранга записи
`RANK()` - вычисляет ранг записи в рамках окна, но с пропусками
`NTILE(<число>)` - используется для разбиения окна на заданное количество групп. Применять только к упорядоченным окнам
`AVG()`, `SUM()`, `COUNT()`

#### Примечание
1. Определить окно можно без использования оператора WINDOW
```
SELECT full_name, salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num
FROM Employees;
```
2. Сортировка записей внутри окна не влияет на их расположение в результирующем наборе. Поэтому при необходимости гарантировать некий порядок записей в результате запроса, его необходимо определить явно в рамках самого запроса.
3. Разбиение окна на секции с помощью оператора `PARTITION BY` выполняется без учета регистра
4. С помощью оператора WINDOW можно определить как одно окно, так и несколько. Во втором случае достаточно перечислить определения всех окон через запятую.
5. Оконные функции применимы только в блоках операторов `SELECT` и `ORDER BY`.

### Границы окон
`ROWS` - ориентируется на расположение записей (например, предыдущая или следующая)

`ROWS BETWEEN <начальная граничная точка> AND <конечная граничная точка>`
- Начальная или конечная граничная точка может быть представлена одним из следующих значений:
  - `CURRENT ROW` — текущая запись
  - `n PRECEDING` — n-ая запись перед текущей
  - `n FOLLOWING` — n-ая запись после текущей
  - `UNBOUNDED PRECEDING` — самая первая запись окна (или секции окна, если было применено секционирование)
  - `UNBOUNDED FOLLOWING` — самая последняя запись окна (или секции окна, если было применено секционирование)
```
SELECT id, full_name, salary,
       AVG(salary) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS avg_salary
FROM Employees;
```

#### Примечание
1. Определенные в окне границы учитывают только агрегатные функции, а также некоторые функции смещения
2. Во время использования оконных границ важно, чтобы окно было упорядочено
3. Если часть окна, полученная в результате применения установленных границ, не содержит ни одной записи, то результатом вызова оконной функции относительно данной части окна будет значение NULL
4. Часть окна, получаемая в результате применения установленных границ, называется __фреймом__.

`RANGE` - ориентируется на их значение в том поле, по которому было упорядочено окно. Позволяет определять не столько границы, сколько диапазоны.

`RANGE BETWEEN a PRECEDING AND b FOLLOWING` - входят записи `[x - a; x + b]`

#### Примечание
1. CURRENT ROW в контексте оператора RANGE можно трактовать как 0 PRECEDING или 0 FOLLOWING
2. Окно, границы которого определяются с помощью оператора RANGE, должно быть упорядочено только по одному полю
3.  Поле, которое используется оператором RANGE для определения границ, должно содержать только числа, даты, временные значения или значения даты и времени.
4.  Окно всегда имеет границы, определенные по умолчанию, которые зависят от того, упорядочено окно или нет. Если окно не упорядочено, границы определяются следующим образом:

`RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`

если упорядочено — следующим образом:

`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

### Функции смещения
`FIRST_VALUE()` - используется для получения значения, которое содержится в определенном поле первой записи окна.

```

SELECT id, full_name, salary,
       FIRST_VALUE(salary) OVER (ORDER BY id) AS first_employee_salary
FROM Employees;
```

`LAST_VALUE()` -  используется для получения значения, которое содержится в определенном поле последней записи окна. (в запросе нужно добавить границы `RANGE`)
`NTH_VALUE(<поле>, n)` - используется для получения значения, которое содержится в определенном поле n-ой записи окна (начиная с 1). (в запросе нужно добавить границы `RANGE`)
`LAG(<поле>, n, <необяз. Значение возвращаемое если null>)` - используется для получения значения, которое содержится в определенном поле записи окна, отстающей от текущей на n
`LEAD(<поле>, n), <необяз. Значение возвращаемое если null>` - используется для получения значения, которое содержится в определенном поле записи окна, опережающей текущую на n. Игнорирует границы окна

```
SELECT id, full_name, salary,
       LAG(salary, 1) OVER (ORDER BY id) AS prev_employee_salary
FROM Employees;
```

 #### Примечания
 1. Функции FIRST_VALUE(), LAST_VALUE() и NTH_VALUE(), называемые функциями смещения, практически всегда используются только с упорядоченными окнами.
 2. Функция NTH_VALUE() возвращает значение NULL, если пытается получить значение записи, выходящей за рамки окна.
 3. LAG и LEAD по умолчанию принимают значение 1
 4. Границы в окне учитывают только агрегатные функции, FIRST_VALUE, LAST_VALUE, и NTH_VALUE


## Регулярные выражения
В SQL регулярные выражения по умолчанию регистронезависимые

- `REGEXP_LIKE()` -  используется для того, чтобы узнать, есть ли совпадение с шаблоном регулярного выражения в строке. (можно использовать совместно с оператором NOT)
  - `str` - исходная строка
  - `pattern` — шаблон регулярного выражения
  - `flags` — флаги сопоставления (может не указываться)(можно комбинировать)
    - `c` - если требуется учитывать регистр
    -  `m` - Чтобы правильным образом обрабатывать символы \n
    -  `n` - Метасимволу . соответствует любой символ кроме символа \n. Для того, чтобы он учитывал и этот символ, необходимо использовать флаг n

- `REGEXP_INSTR()` определение местоположения подстроки

  - `str` — исходная строка
  - `pattern` — шаблон регулярного выражения
  - `start` — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)
  - `occurence` — номер совпадения (может не указываться, в таком случае осуществляется поиск первого совпадения)
  - `return_option` — тип возвращаемой позиции (может не указываться, в таком случае будет возвращена позиция совпадения)
  - `flags` — флаги сопоставления (может не указываться)

- `REGEXP_SUBSTR()` используется для извлечения подстроки, которая совпадает с шаблоном регулярного выражения.
  - `str` — исходная строка
  - `pattern` — шаблон регулярного выражения
  - `start` — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)
  - `occurence` — номер совпадения (может не указываться, в таком случае осуществляется поиск первого совпадения)
  - `flags` — флаги сопоставления (может не указываться)


- `REGEXP_REPLACE()` используется для замены подстроки, которая совпадает с шаблоном регулярного выражения.
  - `str` — исходная строка
  - `pattern` — шаблон регулярного выражения
  - `to_str` — строка замены
  - `start` — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)
  - `occurence` — номер совпадения (может не указываться, в таком случае осуществляется поиск всех совпадений)
flags — флаги сопоставления (может не указываться)
Регулярные выражения (regular expression, regex, регулярка) – способ обработки текста, позволяющий находить в строках подстроки по сложным условиям.
| Метасимвол | Диапазон | Описание |
| --- | --- | --- |
| \d |	[0-9] |	любая цифра
| \D |	[^0-9] |	любой нецифровой символ
| \w |	[0-9a-zA-Zа-яА-ЯёЁ_] |	любой алфавитно-цифровой символ и символ _
| \W |	[^0-9a-zA-Zа-яА-ЯёЁ_] |	любой символ, отличный от алфавитно-цифрового и _
| \s |	[ \f\n\r\t\v] |	любой пробельный символ
| \S |	[^ \f\n\r\t\v] |	любой непробельный символ


`+` соответствие одному или более вхождений {1,}
`*` соответствие нулю или более вхождений {0,}
`?` соответствие нулю или одному вхождению {0,1}


| Жадный |	Ленивый |
| - | - |

|* |	*?|
|+ |	+?|
|? |	??|
|{m,n} |	{m,n}?|
|{,n} |	{,n}?|
|{m,} |	{m,}?|

| Шаблон |	Описание |
| {n} |	ровно n повторений |
| {m,n} |	от m до n повторений включительно |
| {m,} |	не менее m повторений |
| {,n} |	не более n повторений |
| ? |	ноль или одно вхождение, синоним {0,1} |
| * |	ноль или более вхождений, синоним {0,} |
| + |	одно или более вхождений, синоним {1,} |
