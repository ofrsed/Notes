![image](https://github.com/user-attachments/assets/5b924afc-25a3-43e1-a7db-40a35c6be79a)

Брокер сообщений - это какой-то сервис, который может хранить сообщения в упорядоченном виде, в который кто-то (producer, publisher) может отправить сообщение (enqueue), а кто-то (consumer, subscriber) его оттуда прочитать (dequeue).

__Publisher__ - (паблишер, издатель - от английского publish - публиковать), producer - это тот, кто публикует сообщение в RabbitMQ. Это может быть вообще любой сервис, который хочет связаться с любым другим сервисом с помощью брокера сообщений.

Publisher создаёт соединение (connection) по протоколу AMQP, и в рамках соединения создаёт канал (channel). Если обратиться к в веб-интерфейсу RabbitMQ, то можно увидеть вкладки Connections и Channels, в которых будут отображаться соединения и каналы, создаваемые паблишерами. В рамках одного соединения паблишер может создавать несколько каналов, но так делать не рекомендуется из-за возможного снижения производительности, потенциальных конфликтов, сложности отладки и т.п. Хорошая практика - на одно соединение один канал.

__Exchange__ - точка обмена, обменник, эксчейндж - базовая сущность RabbitMQ, отвечающая за машрутизацию всех сообщений от всех паблишеров. Паблишеры помещают свои сообщения в exchange, а уже оттуда они распределяются по дальнейшим компонентам системы.

Нужно отметить три важные особенности точек обмена:
1. Все сообщения от паблишеров всегда попадают сначала в exchange.
2. Если маршрута для сообщения нет, то сообщение будет удалено из системы. Exchange не подразумевает хранения сообщений, только их маршрутизацию.
3. Точек обмена может быть много в системе. Есть обменники по умолчанию и можно создавать кастомные.


__Binding__ (привязка) - связь между точками обмена и очередями, статический маршрут. Задача этой сущности направлять сообщения из exchange в определенную очередь. С помощью привязок можно создавать сложные схемы маршрутизации сообщений и управлять тем, как сообщения доставляются и обрабатываются в системе.

Queue - очередь. Отвечает за хранение сообщений. Информация об очередях, имеющихся в RabbitMQ на текущий момент, доступна во вкладке Queues and Streams веб-интерфейса и здесь же вручную можно добавлять новые очереди

__Message__ - сообщение - основная базовая сущность в рамках брокеров сообщений, отвечающая, за полезную информацию, которую нужно передать с помощью брокера. Собственно, это тот компонент, вокруг которого существует вся система. Сообщение проходит через все этапы обработки от паблишера к консьюмеру.

Возможно, термин "сообщение" может создать немного неверное представление о том, какая информация может быть передана с помощью RabbitMQ. Часто мы представляем себе какие-то осмысленные строки, когда говорим о сообщениях. И хотя через брокер очень часто передаются строковые сообщения, это не значит, что сервис может работать только с ними. Это также могут быть просто наборы байтов, с помощью которых можно передавать любые объекты: хоть картинки, хоть звук, хоть видео. Правда, нужно иметь в виду, что чем больше такие сообщения по объему, тем больше задержки в очередях, ведь для того, чтобы взять в обработку следующее сообщение, сначала нужно обработать текущее. Ну, и есть лимиты и рекомендации на размер сообщений.

__Consumer__ (консьюмер, получатель, подписчик, subscriber) - сущность, получающая сообщения из очереди для того, чтобы что-то, в связи с этим, сделать. Consumer, как и publisher создает соединение, а внутри него канал. Консьюмер может подписаться только на одну очередь и при появлении в этой очереди сообщения, RabbitMQ отправляет сообщение консьюмеру.

Для подтверждения обработки сообщения консьюмером существует механизм Acknowledge (ack), а также механизм возвращения сообщения обратно в очередь при неудачной обработке - Negative acknowledge (nack). Механизм nack также срабатывает автоматически при разрушении канала с консьюмером. Это дает дополнительную гарантию того, что сообщение будет обработано консьюмером, даже если он временно недоступен и сообщение потерялось по пути.
