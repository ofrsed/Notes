__Структуры данных__

- ["О" большое](#О-большое)
- [Массивы](#Массивы)
  - [Статический массив](#Статический-массив)
  - [Динамический массив](#Динамический-массив)
- [Связные списки](#Связные-списки)
  - [Односвязный список](#Односвязный-список)
  - [Двусвязный список](#Двусвязный-список)
- [Очередь](#Очередь)
- [Стеки](#)
- [Деревья](#)
  - [Бинарное дерево](#Бинарное-дерево)
- [Графы](#)
- [Боры](#)
- [Хэш-таблицы](#)




# О большое
<img src="https://github.com/ofrsed/Notes/blob/main/data%20structures%20and%20algorithms/O.png" title="python" alt="python" width="600"  />;

`О большое` - запись для оценки худшего случая, или для ограничения заданной функции сверху. Это позволяет сделать асимптотическую оценку верхней границы скорости роста времени выполнения алгоритма.







# Бинарный поиск (log n)

```
d = [-1, -3, 2, 4, 5, 7, 8, 9]
n = len(d)
 
search_v = 9
left, right = 0, n-1
 
while left <= right:
    middle = (left + right) // 2
    v = d[middle]
    if v == search_v:
        print(v, middle)
        break
    elif v < search_v:
        left = middle + 1
    elif v > search_v:
        right = middle - 1
else:
    print("значение не найдено")
```

NP - полные задачи. Число всех возможных вариантов = n! (факториал)

# Массивы

## Статический массив
Статический массив - массив, который не изменяет свой размер
1. Все элементы должны быть одного типа данных
2. Фиксированные число элементов
3. Все элементы располагаются в памяти подряд, без пропусков

Преимущества
- Скорость доступа к произвольному элементу О(1) для записи или чтения значения
- Просто реализуется и удобен для небольшого набора данных
Недостатки
- Хранение данных выполняется в непрерывной области памяти. Не всегда эффективно для больших объемов данных
- Не может менять число элементов в процессе работы программы Если зарезервированного места недостаточно, данные могут потеряться
- Вставка и удаление выполняются за О(n)

## Динамический массив
Динамический массив - это массив, который может менять число своих элементов в процессе работы программы. Если массива недостаточно, то создается массив в несколько раз больше предыдущего

Минусы

# Связные списки

## Односвязный список

Односвязный список - элементы ссылаются друг на друга попорядку
<img src="https://github.com/ofrsed/Notes/blob/main/data%20structures%20and%20algorithms/img/%D0%BE%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA.png" alt="python" width="600"  />;


Добавление в начало
Вставка в центр O(n)
Добавление в конец
Получить по индексу O(n)
Удаление
Добавление в середину

## Двусвязный список
<img src="https://github.com/ofrsed/Notes/blob/main/data%20structures%20and%20algorithms/img/%D0%94%D0%B2%D1%83%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA.jpg" alt="python" width="800"  />;

||Команда| Big O |
|-|-|-|
| Добавление в начало | push_front() | O(1) |
| Добавление в конец | push_back() | O(1) |
| Удаление с конца | pop_back() | O(1) |
| Удаление с начала | pop_front() | O(1) |
| Вставка элемента | insert() | O(n) |
| Удаление промежуточных элементов | erase() | O(n) |
| Доступ к элементу | at() | O(n) |


# Очередь
Работает только с граничными элементами
Чаще для них используют двусвязные списки. Называются deque)
в python `from collections import deque`

## FIFO (First In, Forst Out)
Кто первым пришел, первыым и ушел

## LIFO (Last In, First Out)
Последним пришел, первым вышел

# Стек
O(1)
Организован по LIFO, единственное отличий что нельзя обращаться к произвольным элементам.
Та же очередь, но с ограниченным функционалом
В нем возможна работа только с верхними элементами
в python лучше сделать через `from collections import deque`

# Деревья
## Бинарное дерево
O(log n)
<img src="https://github.com/ofrsed/Notes/blob/main/data%20structures%20and%20algorithms/img/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B5%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE.png" alt="python" width="800"  />;

Правила формирования
- если добавляемое значение меньше значения в родительском узле, то новая вершина добавляет в левую ветвь, иначе – в правую
- если добавляемое значение уже присутствует в дереве, то оно игнорируется (то есть, дубли отсутствуют).
